"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _classCallCheck = (__webpack_require__(/*! @swc/helpers/lib/_class_call_check.js */ \"./node_modules/@swc/helpers/lib/_class_call_check.js\")[\"default\"]);\nvar _createClass = (__webpack_require__(/*! @swc/helpers/lib/_create_class.js */ \"./node_modules/@swc/helpers/lib/_create_class.js\")[\"default\"]);\nvar _slicedToArray = (__webpack_require__(/*! @swc/helpers/lib/_sliced_to_array.js */ \"./node_modules/@swc/helpers/lib/_sliced_to_array.js\")[\"default\"]);\nvar _tsGenerator = (__webpack_require__(/*! @swc/helpers/lib/_ts_generator.js */ \"./node_modules/@swc/helpers/lib/_ts_generator.js\")[\"default\"]);\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.matchesMiddleware = matchesMiddleware;\nexports.createKey = createKey;\nexports[\"default\"] = void 0;\nvar _async_to_generator = (__webpack_require__(/*! @swc/helpers/lib/_async_to_generator.js */ \"./node_modules/@swc/helpers/lib/_async_to_generator.js\")[\"default\"]);\nvar _extends = (__webpack_require__(/*! @swc/helpers/lib/_extends.js */ \"./node_modules/@swc/helpers/lib/_extends.js\")[\"default\"]);\nvar _interop_require_default = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_default.js */ \"./node_modules/@swc/helpers/lib/_interop_require_default.js\")[\"default\"]);\nvar _interop_require_wildcard = (__webpack_require__(/*! @swc/helpers/lib/_interop_require_wildcard.js */ \"./node_modules/@swc/helpers/lib/_interop_require_wildcard.js\")[\"default\"]);\nvar _removeTrailingSlash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeLoader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nvar _isError = _interop_require_wildcard(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizePagePath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizeLocalePath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = _interop_require_default(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parseRelativeUrl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _resolveRewrites = _interop_require_default(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeRegex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formatUrl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectDomainLocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsePath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addLocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _removeLocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nvar _removeBasePath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _addBasePath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _hasBasePath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _isApiRoute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nvar _getNextPathnameInfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatNextPathnameInfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _compareStates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _isLocalUrl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _isBot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _resolveHref = __webpack_require__(/*! ./utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nvar _interpolateAs = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nvar _handleSmoothScroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator(function(options) {\n        var matchers, _parsePath1, asPathname, cleanedAs, asWithBasePathAndLocale;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        Promise.resolve(options.router.pageLoader.getMiddleware())\n                    ];\n                case 1:\n                    matchers = _state.sent();\n                    if (!matchers) return [\n                        2,\n                        false\n                    ];\n                    _parsePath1 = (0, _parsePath).parsePath(options.asPath), asPathname = _parsePath1.pathname;\n                    cleanedAs = (0, _hasBasePath).hasBasePath(asPathname) ? (0, _removeBasePath).removeBasePath(asPathname) : asPathname;\n                    asWithBasePathAndLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(cleanedAs, options.locale));\n                    // Check only path match on client. Matching \"has\" should be done on server\n                    // where we can access more info such as headers, HttpOnly cookie, etc.\n                    return [\n                        2,\n                        matchers.some(function(m) {\n                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n                        })\n                    ];\n            }\n        });\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils).getLocationOrigin();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var _resolveHref1 = _slicedToArray((0, _resolveHref).resolveHref(router, url, true), 2), resolvedHref = _resolveHref1[0], resolvedAs = _resolveHref1[1];\n    var origin = (0, _utils).getLocationOrigin();\n    var hrefWasAbsolute = resolvedHref.startsWith(origin);\n    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addBasePath).addBasePath(resolvedHref);\n    var preparedAs = as ? stripOrigin((0, _resolveHref).resolveHref(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addBasePath).addBasePath(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _removeTrailingSlash).removeTrailingSlash((0, _denormalizePagePath).denormalizePagePath(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isDynamic).isDynamicRoute(page) && (0, _routeRegex).getRouteRegex(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    var nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    var matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            var parsedRewriteTarget = (0, _parseRelativeUrl).parseRelativeUrl(rewriteTarget);\n            var pathnameInfo = (0, _getNextPathnameInfo).getNextPathnameInfo(parsedRewriteTarget.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            });\n            var fsPathname = (0, _removeTrailingSlash).removeTrailingSlash(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeLoader).getClientBuildManifest()\n            ]).then(function(param) {\n                var _param = _slicedToArray(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;\n                var as = (0, _addLocale).addLocale(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isDynamic).isDynamicRoute(as) || !rewriteHeader && pages.includes((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(as), options.router.locales).pathname)) {\n                    var parsedSource = (0, _getNextPathnameInfo).getNextPathnameInfo((0, _parseRelativeUrl).parseRelativeUrl(source).pathname, {\n                        parseData: true\n                    });\n                    as = (0, _addBasePath).addBasePath(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) { var result; } else if (!pages.includes(fsPathname)) {\n                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizeLocalePath).normalizeLocalePath((0, _removeBasePath).removeBasePath(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isDynamic).isDynamicRoute(resolvedHref)) {\n                    var matches = (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref: resolvedHref\n                };\n            });\n        }\n        var src = (0, _parsePath).parsePath(source);\n        var pathname = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src.pathname, {\n            nextConfig: nextConfig,\n            parseData: true\n        }), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\".concat(pathname).concat(src.query).concat(src.hash)\n        });\n    }\n    var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            var src1 = (0, _parsePath).parsePath(redirectTarget);\n            var pathname1 = (0, _formatNextPathnameInfo).formatNextPathnameInfo(_extends({}, (0, _getNextPathnameInfo).getNextPathnameInfo(src1.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            }), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\".concat(pathname1).concat(src1.query).concat(src1.hash),\n                newUrl: \"\".concat(pathname1).concat(src1.query).concat(src1.hash)\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator(function(options) {\n        var matches, data, effect, e;\n        return _tsGenerator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        matchesMiddleware(options)\n                    ];\n                case 1:\n                    matches = _state.sent();\n                    if (!matches || !options.fetchData) {\n                        return [\n                            2,\n                            null\n                        ];\n                    }\n                    _state.label = 2;\n                case 2:\n                    _state.trys.push([\n                        2,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        options.fetchData()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    return [\n                        4,\n                        getMiddlewareData(data.dataHref, data.response, options)\n                    ];\n                case 4:\n                    effect = _state.sent();\n                    return [\n                        2,\n                        {\n                            dataHref: data.dataHref,\n                            json: data.json,\n                            response: data.response,\n                            text: data.text,\n                            cacheKey: data.cacheKey,\n                            effect: effect\n                        }\n                    ];\n                case 5:\n                    e = _state.sent();\n                    /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` won’t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then(function(response) {\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;\n    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;\n    var ref1;\n    var getData = function(params) {\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (ref1 = params == null ? void 0 : params.method) != null ? ref1 : \"GET\"\n        }).then(function(response) {\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref: dataHref,\n                    response: response,\n                    text: \"\",\n                    json: {},\n                    cacheKey: cacheKey\n                };\n            }\n            return response.text().then(function(text) {\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref: dataHref,\n                            response: response,\n                            text: text,\n                            json: {},\n                            cacheKey: cacheKey\n                        };\n                    }\n                    if (!hasMiddleware && response.status === 404) {\n                        var ref;\n                        if ((ref = tryToParseAsJSON(text)) == null ? void 0 : ref.notFound) {\n                            return {\n                                dataHref: dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response: response,\n                                text: text,\n                                cacheKey: cacheKey\n                            };\n                        }\n                    }\n                    var error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeLoader).markAssetError(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref: dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response: response,\n                    text: text,\n                    cacheKey: cacheKey\n                };\n            });\n        }).then(function(data) {\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        })[\"catch\"](function(err) {\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeLoader).markAssetError(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then(function(data) {\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    var url = param.url, router = param.router;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addBasePath).addBasePath((0, _addLocale).addLocale(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \".concat(url, \" \").concat(location.href));\n    }\n    window.location.href = url;\n}\nvar getCancelledHandler = function(param) {\n    var route = param.route, router = param.router;\n    var cancelled = false;\n    var cancel = router.clc = function() {\n        cancelled = true;\n    };\n    var handleCancelled = function() {\n        if (cancelled) {\n            var error = new Error('Abort fetching component for route: \"'.concat(route, '\"'));\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname1, query1, as1, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _classCallCheck(this, Router);\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = function(e) {\n            var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n            _this.isFirstPopStateEvent = false;\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var pathname = _this.pathname, query = _this.query;\n                _this.changeState(\"replaceState\", (0, _formatUrl).formatWithValidation({\n                    pathname: (0, _addBasePath).addBasePath(pathname),\n                    query: query\n                }), (0, _utils).getURL());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, as = state.as, options = state.options, key = state.key;\n            if (false) { var v; }\n            _this._key = key;\n            var pathname1 = (0, _parseRelativeUrl).parseRelativeUrl(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && as === (0, _addBasePath).addBasePath(_this.asPath) && pathname1 === (0, _addBasePath).addBasePath(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change(\"replaceState\", url, as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _removeTrailingSlash).removeTrailingSlash(pathname1);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname1 !== \"/_error\") {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            var BloomFilter = (__webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter/index.js\").BloomFilter);\n            var staticFilterData = {\"bitset\":{\"size\":16,\"content\":\"qgE=\"},\"hashes\":7,\"size\":9};\n            var dynamicFilterData = {\"bitset\":{\"size\":0,\"content\":\"\"},\"hashes\":null,\"size\":0};\n            if (staticFilterData == null ? void 0 : staticFilterData.hashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.size, staticFilterData.hashes);\n                this._bfl_s[\"import\"](staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.hashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.size, dynamicFilterData.hashes);\n                this._bfl_d[\"import\"](dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isDynamic).isDynamicRoute(pathname1) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname1,\n            query: query1,\n            asPath: autoExportDynamic ? pathname1 : as1,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as1.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options = {\n                    locale: locale\n                };\n                var asPath = (0, _utils).getURL();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale: locale,\n                    asPath: asPath\n                }).then(function(matches) {\n                    options._shouldResolveHref = as1 !== pathname1;\n                    _this.changeState(\"replaceState\", matches ? asPath : (0, _formatUrl).formatWithValidation({\n                        pathname: (0, _addBasePath).addBasePath(pathname1),\n                        query: query1\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _createClass(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Go forward in history\n   */ key: \"forward\",\n            value: function forward() {\n                window.history.forward();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"pushState\", url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as) {\n                var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"replaceState\", url, as, options);\n            }\n        },\n        {\n            key: \"_bfl\",\n            value: function _bfl(as, resolvedAs, locale) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var matchesBflStatic, matchesBflDynamic, _i, _iter, curAs, asNoSlash, asNoSlashLocale, ref, ref2, _i1, _iter1, normalizedAS, curAsParts, i, ref3, currentPart;\n                    return _tsGenerator(this, function(_state) {\n                        if (true) {\n                            matchesBflStatic = false;\n                            matchesBflDynamic = false;\n                            for(_i = 0, _iter = [\n                                as,\n                                resolvedAs\n                            ]; _i < _iter.length; _i++){\n                                curAs = _iter[_i];\n                                if (curAs) {\n                                    asNoSlash = (0, _removeTrailingSlash).removeTrailingSlash(new URL(curAs, \"http://n\").pathname);\n                                    asNoSlashLocale = (0, _addBasePath).addBasePath((0, _addLocale).addLocale(asNoSlash, locale || _this.locale));\n                                    if (asNoSlash !== (0, _removeTrailingSlash).removeTrailingSlash(new URL(_this.asPath, \"http://n\").pathname)) {\n                                        ;\n                                        matchesBflStatic = matchesBflStatic || !!((ref = _this._bfl_s) == null ? void 0 : ref.has(asNoSlash)) || !!((ref2 = _this._bfl_s) == null ? void 0 : ref2.has(asNoSlashLocale));\n                                        for(_i1 = 0, _iter1 = [\n                                            asNoSlash,\n                                            asNoSlashLocale\n                                        ]; _i1 < _iter1.length; _i1++){\n                                            normalizedAS = _iter1[_i1];\n                                            curAsParts = normalizedAS.split(\"/\");\n                                            for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                                ;\n                                                currentPart = curAsParts.slice(0, i).join(\"/\");\n                                                if (currentPart && ((ref3 = _this._bfl_d) == null ? void 0 : ref3.has(currentPart))) {\n                                                    matchesBflDynamic = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        // if the client router filter is matched then we trigger\n                                        // a hard navigation\n                                        if (matchesBflStatic || matchesBflDynamic) {\n                                            handleHardNavigation({\n                                                url: (0, _addBasePath).addBasePath((0, _addLocale).addLocale(as, locale || _this.locale)),\n                                                router: _this\n                                            });\n                                            return [\n                                                2,\n                                                new Promise(function() {})\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            2\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, ref, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref1, ref2, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, ref4, ref5, ref6, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _route, isValidShallowRoute, _scroll, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, ref7, ref8, ref9, err2, canSkipUpdating, e, hashRegex, err11;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!(0, _isLocalUrl).isLocalURL(url)) {\n                                    handleHardNavigation({\n                                        url: url,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                isQueryUpdating = options._h === 1;\n                                if (!!isQueryUpdating) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, undefined, options.locale)\n                                ];\n                            case 1:\n                                _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsePath).parsePath(url).pathname === (0, _parsePath).parsePath(as).pathname;\n                                nextState = _extends({}, _this.state);\n                                readyStateChange = _this.isReady !== true;\n                                _this.isReady = true;\n                                isSsr = _this.isSsr;\n                                if (!isQueryUpdating) {\n                                    _this.isSsr = false;\n                                }\n                                // if a route transition is already in progress before\n                                // the query updating is triggered ignore query updating\n                                if (isQueryUpdating && _this.clc) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                prevLocale = nextState.locale;\n                                if (false) {}\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark(\"routeChange\");\n                                }\n                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute && _this.clc) {\n                                    if (!isSsr) {\n                                        Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                                    }\n                                    _this.clc();\n                                    _this.clc = null;\n                                }\n                                as = (0, _addBasePath).addBasePath((0, _addLocale).addLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = (0, _removeLocale).removeLocale((0, _hasBasePath).hasBasePath(as) ? (0, _removeBasePath).removeBasePath(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) return [\n                                    3,\n                                    7\n                                ];\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _extends({}, options, {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(nextState, _this.components[nextState.route], null)\n                                ];\n                            case 4:\n                                _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                err = _state.sent();\n                                if ((0, _isError)[\"default\"](err) && err.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                                }\n                                throw err;\n                            case 6:\n                                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 7:\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                _state.label = 8;\n                            case 8:\n                                _state.trys.push([\n                                    8,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader.getPageList(),\n                                        (0, _routeLoader).getClientBuildManifest(),\n                                        _this.pageLoader.getMiddleware()\n                                    ])\n                                ];\n                            case 9:\n                                ref1 = _slicedToArray.apply(void 0, [\n                                    _state.sent(),\n                                    2\n                                ]), pages = ref1[0], ref2 = ref1[1], rewrites = ref2.__rewrites, ref2, ref1;\n                                return [\n                                    3,\n                                    11\n                                ];\n                            case 10:\n                                err1 = _state.sent();\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                handleHardNavigation({\n                                    url: as,\n                                    router: _this\n                                });\n                                return [\n                                    2,\n                                    false\n                                ];\n                            case 11:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = \"replaceState\";\n                                }\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _removeTrailingSlash).removeTrailingSlash((0, _removeBasePath).removeBasePath(pathname)) : pathname;\n                                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                                parsedAsPathname = as.startsWith(\"/\") && (0, _parseRelativeUrl).parseRelativeUrl(as).pathname;\n                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isDynamic).isDynamicRoute(route) || !(0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(route))(parsedAsPathname)));\n                                _tmp = !options.shallow;\n                                if (!_tmp) return [\n                                    3,\n                                    13\n                                ];\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: as,\n                                        locale: nextState.locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 12:\n                                _tmp = _state.sent();\n                                _state.label = 13;\n                            case 13:\n                                isMiddlewareMatch = _tmp;\n                                if (isQueryUpdating && isMiddlewareMatch) {\n                                    shouldResolveHref = false;\n                                }\n                                if (shouldResolveHref && pathname !== \"/_error\") {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = (0, _addBasePath).addBasePath(pathname);\n                                            if (!isMiddlewareMatch) {\n                                                url = (0, _formatUrl).formatWithValidation(parsed);\n                                            }\n                                        }\n                                    }\n                                }\n                                if (!(0, _isLocalUrl).isLocalURL(as)) {\n                                    if (true) {\n                                        throw new Error('Invalid href: \"'.concat(url, '\" and as: \"').concat(as, '\", received relative href and external as') + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                                    }\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(resolvedAs), nextState.locale);\n                                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                                routeMatch = false;\n                                if ((0, _isDynamic).isDynamicRoute(route)) {\n                                    parsedAs1 = (0, _parseRelativeUrl).parseRelativeUrl(resolvedAs);\n                                    asPathname = parsedAs1.pathname;\n                                    routeRegex = (0, _routeRegex).getRouteRegex(route);\n                                    routeMatch = (0, _routeMatcher).getRouteMatcher(routeRegex)(asPathname);\n                                    shouldInterpolate = route === asPathname;\n                                    interpolatedAs = shouldInterpolate ? (0, _interpolateAs).interpolateAs(route, asPathname, query) : {};\n                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                            return !query[param] && !routeRegex.groups[param].optional;\n                                        });\n                                        if (missingParams.length > 0 && !isMiddlewareMatch) {\n                                            if (true) {\n                                                console.warn(\"\".concat(shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\", \" failed to manually provide \") + \"the params: \".concat(missingParams.join(\", \"), \" in the `href`'s `query`\"));\n                                            }\n                                            throw new Error((shouldInterpolate ? \"The provided `href` (\".concat(url, \") value is missing query values (\").concat(missingParams.join(\", \"), \") to be interpolated properly. \") : \"The provided `as` value (\".concat(asPathname, \") is incompatible with the `href` value (\").concat(route, \"). \")) + \"Read more: https://nextjs.org/docs/messages/\".concat(shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\"));\n                                        }\n                                    } else if (shouldInterpolate) {\n                                        as = (0, _formatUrl).formatWithValidation(Object.assign({}, parsedAs1, {\n                                            pathname: interpolatedAs.result,\n                                            query: (0, _omit).omit(query, interpolatedAs.params)\n                                        }));\n                                    } else {\n                                        // Merge params into `query`, overwriting any specified in search\n                                        Object.assign(query, routeMatch);\n                                    }\n                                }\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeStart\", as, routeProps);\n                                }\n                                isErrorRoute = _this.pathname === \"/404\" || _this.pathname === \"/_error\";\n                                _state.label = 14;\n                            case 14:\n                                _state.trys.push([\n                                    14,\n                                    35,\n                                    ,\n                                    36\n                                ]);\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: route,\n                                        pathname: pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: routeProps,\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        hasMiddleware: isMiddlewareMatch,\n                                        unstable_skipClientCache: options.unstable_skipClientCache,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                                        isMiddlewareRewrite: isMiddlewareRewrite\n                                    })\n                                ];\n                            case 15:\n                                routeInfo = _state.sent();\n                                if (!!isQueryUpdating) return [\n                                    3,\n                                    17\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)\n                                ];\n                            case 16:\n                                _state.sent();\n                                _state.label = 17;\n                            case 17:\n                                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                                    pathname = routeInfo.route || route;\n                                    route = pathname;\n                                    if (!routeProps.shallow) {\n                                        query = Object.assign({}, routeInfo.query || {}, query);\n                                    }\n                                    cleanedParsedPathname = (0, _hasBasePath).hasBasePath(parsed.pathname) ? (0, _removeBasePath).removeBasePath(parsed.pathname) : parsed.pathname;\n                                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                                        Object.keys(routeMatch).forEach(function(key) {\n                                            if (routeMatch && query[key] === routeMatch[key]) {\n                                                delete query[key];\n                                            }\n                                        });\n                                    }\n                                    if ((0, _isDynamic).isDynamicRoute(pathname)) {\n                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addBasePath).addBasePath((0, _addLocale).addLocale(new URL(as, location.href).pathname, nextState.locale), true);\n                                        rewriteAs = prefixedAs;\n                                        if ((0, _hasBasePath).hasBasePath(rewriteAs)) {\n                                            rewriteAs = (0, _removeBasePath).removeBasePath(rewriteAs);\n                                        }\n                                        if (false) {}\n                                        routeRegex1 = (0, _routeRegex).getRouteRegex(pathname);\n                                        curRouteMatch = (0, _routeMatcher).getRouteMatcher(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                                        if (curRouteMatch) {\n                                            Object.assign(query, curRouteMatch);\n                                        }\n                                    }\n                                }\n                                // If the routeInfo brings a redirect we simply apply it.\n                                if (\"type\" in routeInfo) {\n                                    if (routeInfo.type === \"redirect-internal\") {\n                                        return [\n                                            2,\n                                            _this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n                                        ];\n                                    } else {\n                                        handleHardNavigation({\n                                            url: routeInfo.destination,\n                                            router: _this\n                                        });\n                                        return [\n                                            2,\n                                            new Promise(function() {})\n                                        ];\n                                    }\n                                }\n                                component = routeInfo.Component;\n                                if (component && component.unstable_scriptLoader) {\n                                    scripts = [].concat(component.unstable_scriptLoader());\n                                    scripts.forEach(function(script) {\n                                        (0, _script).handleClientScriptLoad(script.props);\n                                    });\n                                }\n                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [\n                                    3,\n                                    23\n                                ];\n                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                                    // Use the destination from redirect without adding locale\n                                    options.locale = false;\n                                    destination = routeInfo.props.pageProps.__N_REDIRECT;\n                                    // check if destination is internal (resolves to a page) and attempt\n                                    // client-navigation if it is falling back to hard navigation if\n                                    // it's not\n                                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                                        parsedHref = (0, _parseRelativeUrl).parseRelativeUrl(destination);\n                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                        _prepareUrlAs = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;\n                                        return [\n                                            2,\n                                            _this.change(method, newUrl, newAs, options)\n                                        ];\n                                    }\n                                    handleHardNavigation({\n                                        url: destination,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [\n                                    3,\n                                    23\n                                ];\n                                _state.label = 18;\n                            case 18:\n                                _state.trys.push([\n                                    18,\n                                    20,\n                                    ,\n                                    21\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/404\")\n                                ];\n                            case 19:\n                                _state.sent();\n                                notFoundRoute = \"/404\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 20:\n                                _ = _state.sent();\n                                notFoundRoute = \"/_error\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 21:\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: notFoundRoute,\n                                        pathname: notFoundRoute,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview\n                                    })\n                                ];\n                            case 22:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on /404\");\n                                }\n                                _state.label = 23;\n                            case 23:\n                                if (isQueryUpdating && _this.pathname === \"/_error\" && ((ref4 = self.__NEXT_DATA__.props) == null ? void 0 : (ref5 = ref4.pageProps) == null ? void 0 : ref5.statusCode) === 500 && ((ref6 = routeInfo.props) == null ? void 0 : ref6.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                isValidShallowRoute = options.shallow && nextState.route === ((_route = routeInfo.route) != null ? _route : route);\n                                shouldScroll = (_scroll = options.scroll) != null ? _scroll : !isQueryUpdating && !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                                upcomingRouterState = _extends({}, nextState, {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                });\n                                if (!(isQueryUpdating && isErrorRoute)) return [\n                                    3,\n                                    29\n                                ];\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: _this.pathname,\n                                        pathname: _this.pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                                    })\n                                ];\n                            case 24:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on \".concat(_this.pathname));\n                                }\n                                if (_this.pathname === \"/_error\" && ((ref7 = self.__NEXT_DATA__.props) == null ? void 0 : (ref8 = ref7.pageProps) == null ? void 0 : ref8.statusCode) === 500 && ((ref9 = routeInfo.props) == null ? void 0 : ref9.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                _state.label = 25;\n                            case 25:\n                                _state.trys.push([\n                                    25,\n                                    27,\n                                    ,\n                                    28\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 26:\n                                _state.sent();\n                                return [\n                                    3,\n                                    28\n                                ];\n                            case 27:\n                                err2 = _state.sent();\n                                if ((0, _isError)[\"default\"](err2) && err2.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err2, cleanedAs, routeProps);\n                                }\n                                throw err2;\n                            case 28:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 29:\n                                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _compareStates).compareRouterStates(upcomingRouterState, _this.state);\n                                if (!!canSkipUpdating) return [\n                                    3,\n                                    34\n                                ];\n                                _state.label = 30;\n                            case 30:\n                                _state.trys.push([\n                                    30,\n                                    32,\n                                    ,\n                                    33\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 31:\n                                _state.sent();\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 32:\n                                e = _state.sent();\n                                if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                                else throw e;\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 33:\n                                if (routeInfo.error) {\n                                    if (!isQueryUpdating) {\n                                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                                    }\n                                    throw routeInfo.error;\n                                }\n                                if (false) {}\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                                }\n                                hashRegex = /#.+$/;\n                                if (shouldScroll && hashRegex.test(as)) {\n                                    _this.scrollToHash(as);\n                                }\n                                _state.label = 34;\n                            case 34:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 35:\n                                err11 = _state.sent();\n                                if ((0, _isError)[\"default\"](err11) && err11.cancelled) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                throw err11;\n                            case 36:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as) {\n                var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (true) {\n                    if (typeof window.history === \"undefined\") {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === \"undefined\") {\n                        console.error(\"Warning: window.history.\".concat(method, \" is not available\"));\n                        return;\n                    }\n                }\n                if (method !== \"pushState\" || (0, _utils).getURL() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        key: this._key = method !== \"pushState\" ? this._key : createKey()\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState\n                    \"\", as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                console.error(err);\n                                if (err.cancelled) {\n                                    // bubble up cancellation errors\n                                    throw err;\n                                }\n                                if ((0, _routeLoader).isAssetError(err) || loadErrorFail) {\n                                    Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                                    // If we can't load the page it could be one of following reasons\n                                    //  1. Page doesn't exists\n                                    //  2. Page does exist in a different zone\n                                    //  3. Internal error while loading the page\n                                    // So, doing a hard reload is the proper way to deal with this.\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    // Changing the URL doesn't block executing the current code path.\n                                    // So let's throw a cancellation error stop the routing logic.\n                                    throw buildCancellationError();\n                                }\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    7,\n                                    ,\n                                    8\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/_error\")\n                                ];\n                            case 2:\n                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (!!routeInfo.props) return [\n                                    3,\n                                    6\n                                ];\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.getInitialProps(Component, {\n                                        err: err,\n                                        pathname: pathname,\n                                        query: query\n                                    })\n                                ];\n                            case 4:\n                                routeInfo.props = _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                gipErr = _state.sent();\n                                console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                                routeInfo.props = {};\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 6:\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 7:\n                                routeInfoErr = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _isError)[\"default\"](routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true)\n                                ];\n                            case 8:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(param) {\n                var requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite;\n                var _this = this;\n                return _async_to_generator(function() {\n                    var route, ref, ref10, ref11, ref12, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                route = requestedRoute;\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                existingInfo = _this.components[route];\n                                if (routeProps.shallow && existingInfo && _this.route === route) {\n                                    return [\n                                        2,\n                                        existingInfo\n                                    ];\n                                }\n                                if (hasMiddleware) {\n                                    existingInfo = undefined;\n                                }\n                                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                                isBackground = isQueryUpdating;\n                                fetchNextDataParams = {\n                                    dataHref: _this.pageLoader.getDataHref({\n                                        href: (0, _formatUrl).formatWithValidation({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        skipInterpolation: true,\n                                        asPath: resolvedAs,\n                                        locale: locale\n                                    }),\n                                    hasMiddleware: true,\n                                    isServerRender: _this.isSsr,\n                                    parseJSON: true,\n                                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                                    persistCache: !isPreview,\n                                    isPrefetch: false,\n                                    unstable_skipClientCache: unstable_skipClientCache,\n                                    isBackground: isBackground\n                                };\n                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [\n                                    3,\n                                    2\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    4\n                                ];\n                            case 2:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData(fetchNextDataParams);\n                                        },\n                                        asPath: resolvedAs,\n                                        locale: locale,\n                                        router: _this\n                                    })[\"catch\"](function(err) {\n                                        // we don't hard error during query updating\n                                        // as it's un-necessary and doesn't need to be fatal\n                                        // unless it is a fallback route and the props can't\n                                        // be loaded\n                                        if (isQueryUpdating) {\n                                            return null;\n                                        }\n                                        throw err;\n                                    })\n                                ];\n                            case 3:\n                                _tmp = _state.sent();\n                                _state.label = 4;\n                            case 4:\n                                data = _tmp;\n                                if (isQueryUpdating) {\n                                    if (!data) {\n                                        data = {\n                                            json: self.__NEXT_DATA__.props\n                                        };\n                                    } else {\n                                        data.json = self.__NEXT_DATA__.props;\n                                    }\n                                }\n                                handleCancelled();\n                                if ((data == null ? void 0 : (ref = data.effect) == null ? void 0 : ref.type) === \"redirect-internal\" || (data == null ? void 0 : (ref10 = data.effect) == null ? void 0 : ref10.type) === \"redirect-external\") {\n                                    return [\n                                        2,\n                                        data.effect\n                                    ];\n                                }\n                                if (!((data == null ? void 0 : (ref11 = data.effect) == null ? void 0 : ref11.type) === \"rewrite\")) return [\n                                    3,\n                                    6\n                                ];\n                                resolvedRoute = (0, _removeTrailingSlash).removeTrailingSlash(data.effect.resolvedHref);\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 5:\n                                pages = _state.sent();\n                                // during query updating the page must match although during\n                                // client-transition a redirect that doesn't match a page\n                                // can be returned and this should trigger a hard navigation\n                                // which is valid for incremental migration\n                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                                    route = resolvedRoute;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _extends({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = (0, _removeBasePath).removeBasePath((0, _normalizeLocalePath).normalizeLocalePath(data.effect.parsedAs.pathname, _this.locales).pathname);\n                                    // Check again the cache with the new destination.\n                                    existingInfo = _this.components[route];\n                                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                                        // If we have a match with the current route due to rewrite,\n                                        // we can copy the existing information to the rewritten one.\n                                        // Then, we return the information along with the matched route.\n                                        return [\n                                            2,\n                                            _extends({}, existingInfo, {\n                                                route: route\n                                            })\n                                        ];\n                                    }\n                                }\n                                _state.label = 6;\n                            case 6:\n                                if ((0, _isApiRoute).isAPIRoute(route)) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _tmp1 = cachedRouteInfo;\n                                if (_tmp1) return [\n                                    3,\n                                    8\n                                ];\n                                return [\n                                    4,\n                                    _this.fetchComponent(route).then(function(res) {\n                                        return {\n                                            Component: res.page,\n                                            styleSheets: res.styleSheets,\n                                            __N_SSG: res.mod.__N_SSG,\n                                            __N_SSP: res.mod.__N_SSP\n                                        };\n                                    })\n                                ];\n                            case 7:\n                                _tmp1 = _state.sent();\n                                _state.label = 8;\n                            case 8:\n                                routeInfo = _tmp1;\n                                if (true) {\n                                    isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                    if (!isValidElementType(routeInfo.Component)) {\n                                        throw new Error('The default export is not a React Component in page: \"'.concat(pathname, '\"'));\n                                    }\n                                }\n                                wasBailedPrefetch = data == null ? void 0 : (ref12 = data.response) == null ? void 0 : ref12.headers.get(\"x-middleware-skip\");\n                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                                // For non-SSG prefetches that bailed before sending data\n                                // we clear the cache to fetch full response\n                                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                                    delete _this.sdc[data.dataHref];\n                                }\n                                return [\n                                    4,\n                                    _this._getData(_async_to_generator(function() {\n                                        var dataHref, fetched, _tmp;\n                                        return _tsGenerator(this, function(_state) {\n                                            switch(_state.label){\n                                                case 0:\n                                                    if (!shouldFetchData) return [\n                                                        3,\n                                                        2\n                                                    ];\n                                                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                                                        return [\n                                                            2,\n                                                            {\n                                                                cacheKey: data.cacheKey,\n                                                                props: data.json\n                                                            }\n                                                        ];\n                                                    }\n                                                    dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                                                        href: (0, _formatUrl).formatWithValidation({\n                                                            pathname: pathname,\n                                                            query: query\n                                                        }),\n                                                        asPath: resolvedAs,\n                                                        locale: locale\n                                                    });\n                                                    return [\n                                                        4,\n                                                        fetchNextData({\n                                                            dataHref: dataHref,\n                                                            isServerRender: _this.isSsr,\n                                                            parseJSON: true,\n                                                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                                                            persistCache: !isPreview,\n                                                            isPrefetch: false,\n                                                            unstable_skipClientCache: unstable_skipClientCache\n                                                        })\n                                                    ];\n                                                case 1:\n                                                    fetched = _state.sent();\n                                                    return [\n                                                        2,\n                                                        {\n                                                            cacheKey: fetched.cacheKey,\n                                                            props: fetched.json || {}\n                                                        }\n                                                    ];\n                                                case 2:\n                                                    _tmp = {\n                                                        headers: {}\n                                                    };\n                                                    return [\n                                                        4,\n                                                        _this.getInitialProps(routeInfo.Component, {\n                                                            pathname: pathname,\n                                                            query: query,\n                                                            asPath: as,\n                                                            locale: locale,\n                                                            locales: _this.locales,\n                                                            defaultLocale: _this.defaultLocale\n                                                        })\n                                                    ];\n                                                case 3:\n                                                    return [\n                                                        2,\n                                                        (_tmp.props = _state.sent(), _tmp)\n                                                    ];\n                                            }\n                                        });\n                                    }))\n                                ];\n                            case 9:\n                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;\n                                // Only bust the data cache for SSP routes although\n                                // middleware can skip cache per request with\n                                // x-middleware-cache: no-cache as well\n                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                                    delete _this.sdc[cacheKey];\n                                }\n                                // we kick off a HEAD request in the background\n                                // when a non-prefetch request is made to signal revalidation\n                                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                                props.pageProps = Object.assign({}, props.pageProps);\n                                routeInfo.props = props;\n                                routeInfo.route = route;\n                                routeInfo.query = query;\n                                routeInfo.resolvedAs = resolvedAs;\n                                _this.components[route] = routeInfo;\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 10:\n                                err = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _isError).getProperError(err), pathname, query, as, routeProps)\n                                ];\n                            case 11:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var _this_asPath_split = _slicedToArray(this.asPath.split(\"#\"), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];\n                var _as_split = _slicedToArray(as.split(\"#\"), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var _as_split = _slicedToArray(as.split(\"#\"), 2), tmp = _as_split[1], hash = tmp === void 0 ? \"\" : tmp;\n                // Scroll to top if the hash is just `#` with no value or `#top`\n                // To mirror browsers\n                if (hash === \"\" || hash === \"top\") {\n                    (0, _handleSmoothScroll).handleSmoothScroll(function() {\n                        return window.scrollTo(0, 0);\n                    });\n                    return;\n                }\n                // Decode hash to make non-latin anchor works.\n                var rawHash = decodeURIComponent(hash);\n                // First we check if the element by id is found\n                var idEl = document.getElementById(rawHash);\n                if (idEl) {\n                    (0, _handleSmoothScroll).handleSmoothScroll(function() {\n                        return idEl.scrollIntoView();\n                    });\n                    return;\n                }\n                // If there's no element with the id, we check the `name` property\n                // To mirror browsers\n                var nameEl = document.getElementsByName(rawHash)[0];\n                if (nameEl) {\n                    (0, _handleSmoothScroll).handleSmoothScroll(function() {\n                        return nameEl.scrollIntoView();\n                    });\n                }\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ key: \"prefetch\",\n            value: function prefetch(url) {\n                var asPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : url, options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var _this = this;\n                return _async_to_generator(function() {\n                    var parsed, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                                if (true) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if ( true && (0, _isBot).isBot(window.navigator.userAgent)) {\n                                    // No prefetches for bots that render the link since they are typically navigating\n                                    // links via the equivalent of a hard navigation and hence never utilize these\n                                    // prefetches.\n                                    return [\n                                        2\n                                    ];\n                                }\n                                parsed = (0, _parseRelativeUrl).parseRelativeUrl(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                originalPathname = pathname;\n                                if (false) {}\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 1:\n                                pages = _state.sent();\n                                resolvedAs = asPath;\n                                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 2:\n                                isMiddlewareMatch = _state.sent();\n                                if (true) return [\n                                    3,\n                                    4\n                                ];\n                                return [\n                                    4,\n                                    (0, _routeLoader).getClientBuildManifest()\n                                ];\n                            case 3:\n                                ref = _state.sent(), rewrites = ref.__rewrites, ref;\n                                rewritesResult = (0, _resolveRewrites)[\"default\"]((0, _addBasePath).addBasePath((0, _addLocale).addLocale(asPath, _this.locale), true), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (rewritesResult.externalDest) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if (!isMiddlewareMatch) {\n                                    resolvedAs = (0, _removeLocale).removeLocale((0, _removeBasePath).removeBasePath(rewritesResult.asPath), _this.locale);\n                                }\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formatUrl).formatWithValidation(parsed);\n                                    }\n                                }\n                                _state.label = 4;\n                            case 4:\n                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                if ((0, _isDynamic).isDynamicRoute(parsed.pathname)) {\n                                    pathname = parsed.pathname;\n                                    parsed.pathname = pathname;\n                                    Object.assign(query, (0, _routeMatcher).getRouteMatcher((0, _routeRegex).getRouteRegex(parsed.pathname))((0, _parsePath).parsePath(asPath).pathname) || {});\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formatUrl).formatWithValidation(parsed);\n                                    }\n                                }\n                                if (true) return [\n                                    3,\n                                    5\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    7\n                                ];\n                            case 5:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData({\n                                                dataHref: _this.pageLoader.getDataHref({\n                                                    href: (0, _formatUrl).formatWithValidation({\n                                                        pathname: originalPathname,\n                                                        query: query\n                                                    }),\n                                                    skipInterpolation: true,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                hasMiddleware: true,\n                                                isServerRender: _this.isSsr,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true\n                                            });\n                                        },\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 6:\n                                _tmp = _state.sent();\n                                _state.label = 7;\n                            case 7:\n                                data = _tmp;\n                                /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                                    parsed.pathname = data.effect.resolvedHref;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _extends({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = data.effect.parsedAs.pathname;\n                                    url = (0, _formatUrl).formatWithValidation(parsed);\n                                }\n                                /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                route = (0, _removeTrailingSlash).removeTrailingSlash(pathname);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                            return isSsg ? fetchNextData({\n                                                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                                    href: url,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                isServerRender: false,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true,\n                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                                            }).then(function() {\n                                                return false;\n                                            }) : false;\n                                        }),\n                                        _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n                                    ])\n                                ];\n                            case 8:\n                                _state.sent();\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _async_to_generator(function() {\n                    var handleCancelled, componentResult, err;\n                    return _tsGenerator(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    3,\n                                    ,\n                                    4\n                                ]);\n                                return [\n                                    4,\n                                    _this.pageLoader.loadPage(route)\n                                ];\n                            case 2:\n                                componentResult = _state.sent();\n                                handleCancelled();\n                                return [\n                                    2,\n                                    componentResult\n                                ];\n                            case 3:\n                                err = _state.sent();\n                                handleCancelled();\n                                throw err;\n                            case 4:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error(\"Loading initial props cancelled\");\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData({\n                    dataHref: dataHref,\n                    isServerRender: true,\n                    parseJSON: false,\n                    inflightCache: this.sdc,\n                    persistCache: false,\n                    isPrefetch: false\n                }).then(function(param) {\n                    var text = param.text;\n                    return {\n                        data: text\n                    };\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var _this_components__app = this.components[\"/_app\"], App = _this_components__app.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils).loadGetInitialProps(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt)[\"default\"]();\nexports[\"default\"] = Router; //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPLElBQUk7QUFDZixDQUFDLEVBQUM7QUFDRkQseUJBQXlCLEdBQUdFO0FBQzVCRixpQkFBaUIsR0FBR0c7QUFDcEJILGtCQUFlLEdBQUcsS0FBSztBQUN2QixJQUFJSyxzQkFBc0JDLHlJQUEwRDtBQUNwRixJQUFJQyxXQUFXRCxtSEFBK0M7QUFDOUQsSUFBSUUsMkJBQTJCRixtSkFBK0Q7QUFDOUYsSUFBSUcsNEJBQTRCSCxxSkFBZ0U7QUFDaEcsSUFBSUksdUJBQXVCSixtQkFBT0EsQ0FBQyxnSEFBK0I7QUFDbEUsSUFBSUssZUFBZUwsbUJBQU9BLENBQUMscUZBQThCO0FBQ3pELElBQUlNLFVBQVVOLG1CQUFPQSxDQUFDLHlFQUF3QjtBQUM5QyxJQUFJTyxXQUFXSiwwQkFBMEJILG1CQUFPQSxDQUFDLHVFQUF1QjtBQUN4RSxJQUFJUSx1QkFBdUJSLG1CQUFPQSxDQUFDLGtIQUFvQztBQUN2RSxJQUFJUyx1QkFBdUJULG1CQUFPQSxDQUFDLHdHQUErQjtBQUNsRSxJQUFJVSxRQUFRUix5QkFBeUJGLG1CQUFPQSxDQUFDLDREQUFTO0FBQ3RELElBQUlXLFNBQVNYLG1CQUFPQSxDQUFDLDhEQUFVO0FBQy9CLElBQUlZLGFBQWFaLG1CQUFPQSxDQUFDLDBGQUFvQjtBQUM3QyxJQUFJYSxvQkFBb0JiLG1CQUFPQSxDQUFDLDBHQUE0QjtBQUM1RCxJQUFJYyxtQkFBbUJaLHlCQUF5QkYsbUJBQU9BLENBQUMsdUNBQTBCO0FBQ2xGLElBQUllLGdCQUFnQmYsbUJBQU9BLENBQUMsZ0dBQXVCO0FBQ25ELElBQUlnQixjQUFjaEIsbUJBQU9BLENBQUMsNEZBQXFCO0FBQy9DLElBQUlpQixhQUFhakIsbUJBQU9BLENBQUMsMEZBQW9CO0FBQzdDLElBQUlrQixzQkFBc0JsQixtQkFBT0Es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QUMzSyxNQUFNO1lBQzVCOzs7WUFDSU0sS0FBQUE7aUJBQUosZUFBYTtnQkFDVCxPQUFPLElBQUksQ0FBQ3FLLEtBQUssQ0FBQ3JLLE1BQU07WUFDNUI7OztZQUNJNkosS0FBQUE7aUJBQUosZUFBaUI7Z0JBQ2IsT0FBTyxJQUFJLENBQUNRLEtBQUssQ0FBQ1IsVUFBVTtZQUNoQzs7O1lBQ0lFLEtBQUFBO2lCQUFKLGVBQWdCO2dCQUNaLE9BQU8sSUFBSSxDQUFDTSxLQUFLLENBQUNOLFNBQVM7WUFDL0I7OztXQXRrQ0VYOztBQSt2Q05BLE9BQU95RCxNQUFNLEdBQUcsQ0FBQyxHQUFHOVAsS0FBSyxDQUFFWixDQUFBQSxVQUFPO0FBQ2xDSixrQkFBZSxHQUFHcU4sUUFFbEIsa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyLmpzPzg2ODQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLm1hdGNoZXNNaWRkbGV3YXJlID0gbWF0Y2hlc01pZGRsZXdhcmU7XG5leHBvcnRzLmNyZWF0ZUtleSA9IGNyZWF0ZUtleTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbnZhciBfYXN5bmNfdG9fZ2VuZXJhdG9yID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2FzeW5jX3RvX2dlbmVyYXRvci5qc1wiKS5kZWZhdWx0O1xudmFyIF9leHRlbmRzID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2V4dGVuZHMuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL2xpYi9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuanNcIikuZGVmYXVsdDtcbnZhciBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9saWIvX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZC5qc1wiKS5kZWZhdWx0O1xudmFyIF9yZW1vdmVUcmFpbGluZ1NsYXNoID0gcmVxdWlyZShcIi4vdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoXCIpO1xudmFyIF9yb3V0ZUxvYWRlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvcm91dGUtbG9hZGVyXCIpO1xudmFyIF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbnZhciBfaXNFcnJvciA9IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG52YXIgX2Rlbm9ybWFsaXplUGFnZVBhdGggPSByZXF1aXJlKFwiLi4vcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aFwiKTtcbnZhciBfbm9ybWFsaXplTG9jYWxlUGF0aCA9IHJlcXVpcmUoXCIuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aFwiKTtcbnZhciBfbWl0dCA9IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdChyZXF1aXJlKFwiLi4vbWl0dFwiKSk7XG52YXIgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIF9pc0R5bmFtaWMgPSByZXF1aXJlKFwiLi91dGlscy9pcy1keW5hbWljXCIpO1xudmFyIF9wYXJzZVJlbGF0aXZlVXJsID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsXCIpO1xudmFyIF9yZXNvbHZlUmV3cml0ZXMgPSBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlc1wiKSk7XG52YXIgX3JvdXRlTWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG52YXIgX3JvdXRlUmVnZXggPSByZXF1aXJlKFwiLi91dGlscy9yb3V0ZS1yZWdleFwiKTtcbnZhciBfZm9ybWF0VXJsID0gcmVxdWlyZShcIi4vdXRpbHMvZm9ybWF0LXVybFwiKTtcbnZhciBfZGV0ZWN0RG9tYWluTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbnZhciBfcGFyc2VQYXRoID0gcmVxdWlyZShcIi4vdXRpbHMvcGFyc2UtcGF0aFwiKTtcbnZhciBfYWRkTG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9hZGQtbG9jYWxlXCIpO1xudmFyIF9yZW1vdmVMb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG52YXIgX3JlbW92ZUJhc2VQYXRoID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9yZW1vdmUtYmFzZS1wYXRoXCIpO1xudmFyIF9hZGRCYXNlUGF0aCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWJhc2UtcGF0aFwiKTtcbnZhciBfaGFzQmFzZVBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG52YXIgX2lzQXBpUm91dGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL2lzLWFwaS1yb3V0ZVwiKTtcbnZhciBfZ2V0TmV4dFBhdGhuYW1lSW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG52YXIgX2Zvcm1hdE5leHRQYXRobmFtZUluZm8gPSByZXF1aXJlKFwiLi91dGlscy9mb3JtYXQtbmV4dC1wYXRobmFtZS1pbmZvXCIpO1xudmFyIF9jb21wYXJlU3RhdGVzID0gcmVxdWlyZShcIi4vdXRpbHMvY29tcGFyZS1zdGF0ZXNcIik7XG52YXIgX2lzTG9jYWxVcmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG52YXIgX2lzQm90ID0gcmVxdWlyZShcIi4vdXRpbHMvaXMtYm90XCIpO1xudmFyIF9vbWl0ID0gcmVxdWlyZShcIi4vdXRpbHMvb21pdFwiKTtcbnZhciBfcmVzb2x2ZUhyZWYgPSByZXF1aXJlKFwiLi91dGlscy9yZXNvbHZlLWhyZWZcIik7XG52YXIgX2ludGVycG9sYXRlQXMgPSByZXF1aXJlKFwiLi91dGlscy9pbnRlcnBvbGF0ZS1hc1wiKTtcbnZhciBfaGFuZGxlU21vb3RoU2Nyb2xsID0gcmVxdWlyZShcIi4vdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG5mdW5jdGlvbiBidWlsZENhbmNlbGxhdGlvbkVycm9yKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9tYXRjaGVzTWlkZGxld2FyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX21hdGNoZXNNaWRkbGV3YXJlKCkge1xuICAgIF9tYXRjaGVzTWlkZGxld2FyZSA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcnMgPSB5aWVsZCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgICAgICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgIH0gPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAgICAgLy8gcmVtb3ZlIGJhc2VQYXRoIGZpcnN0IHNpbmNlIHBhdGggcHJlZml4IGhhcyB0byBiZSBpbiB0aGUgb3JkZXIgb2YgYC8ke2Jhc2VQYXRofS8ke2xvY2FsZX1gXG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzUGF0aG5hbWUpID8gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgoYXNQYXRobmFtZSkgOiBhc1BhdGhuYW1lO1xuICAgICAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKCgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgICAgICAvLyBDaGVjayBvbmx5IHBhdGggbWF0Y2ggb24gY2xpZW50LiBNYXRjaGluZyBcImhhc1wiIHNob3VsZCBiZSBkb25lIG9uIHNlcnZlclxuICAgICAgICAvLyB3aGVyZSB3ZSBjYW4gYWNjZXNzIG1vcmUgaW5mbyBzdWNoIGFzIGhlYWRlcnMsIEh0dHBPbmx5IGNvb2tpZSwgZXRjLlxuICAgICAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX21hdGNoZXNNaWRkbGV3YXJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBzdHJpcE9yaWdpbih1cmwpIHtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybDtcbn1cbmZ1bmN0aW9uIHByZXBhcmVVcmxBcyhyb3V0ZXIsIHVybCwgYXMpIHtcbiAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAvLyB3ZSdsbCBmb3JtYXQgdGhlbSBpbnRvIHRoZSBzdHJpbmcgdmVyc2lvbiBoZXJlLlxuICAgIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9ICgwLCBfcmVzb2x2ZUhyZWYpLnJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKTtcbiAgICBjb25zdCBvcmlnaW4gPSAoMCwgX3V0aWxzKS5nZXRMb2NhdGlvbk9yaWdpbigpO1xuICAgIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbik7XG4gICAgcmVzb2x2ZWRIcmVmID0gc3RyaXBPcmlnaW4ocmVzb2x2ZWRIcmVmKTtcbiAgICByZXNvbHZlZEFzID0gcmVzb2x2ZWRBcyA/IHN0cmlwT3JpZ2luKHJlc29sdmVkQXMpIDogcmVzb2x2ZWRBcztcbiAgICBjb25zdCBwcmVwYXJlZFVybCA9IGhyZWZXYXNBYnNvbHV0ZSA/IHJlc29sdmVkSHJlZiA6ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHJlc29sdmVkSHJlZik7XG4gICAgY29uc3QgcHJlcGFyZWRBcyA9IGFzID8gc3RyaXBPcmlnaW4oKDAsIF9yZXNvbHZlSHJlZikucmVzb2x2ZUhyZWYocm91dGVyLCBhcykpIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWY7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICAgICAgYXM6IGFzV2FzQWJzb2x1dGUgPyBwcmVwYXJlZEFzIDogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocHJlcGFyZWRBcylcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRobmFtZSwgcGFnZXMpIHtcbiAgICBjb25zdCBjbGVhblBhdGhuYW1lID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKCgwLCBfZGVub3JtYWxpemVQYWdlUGF0aCkuZGVub3JtYWxpemVQYWdlUGF0aChwYXRobmFtZSkpO1xuICAgIGlmIChjbGVhblBhdGhuYW1lID09PSAnLzQwNCcgfHwgY2xlYW5QYXRobmFtZSA9PT0gJy9fZXJyb3InKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYWdlKSAmJiAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICB9LFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcbiAgICB9O1xuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmV3cml0ZScpO1xuICAgIGxldCByZXdyaXRlVGFyZ2V0ID0gcmV3cml0ZUhlYWRlciB8fCByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtbWF0Y2hlZC1wYXRoJyk7XG4gICAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1tYXRjaGVkLXBhdGgnKTtcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCdfX25leHRfZGF0YV9jYXRjaGFsbCcpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnL19lcnJvcicpICYmICFtYXRjaGVkUGF0aC5pbmNsdWRlcygnLzQwNCcpKSB7XG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgICAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGg7XG4gICAgfVxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSB8fCBwcm9jZXNzLmVudi5fX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJld3JpdGVUYXJnZXQgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwocmV3cml0ZVRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBwYXRobmFtZUluZm8gPSAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8ocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBmc1BhdGhuYW1lID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lSW5mby5wYXRobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucm91dGVyLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKSxcbiAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksIFxuICAgICAgICAgICAgXSkudGhlbigoW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSk9PntcbiAgICAgICAgICAgICAgICBsZXQgYXMgPSAoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKHBhdGhuYW1lSW5mby5wYXRobmFtZSwgcGF0aG5hbWVJbmZvLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShhcykgfHwgIXJld3JpdGVIZWFkZXIgJiYgcGFnZXMuaW5jbHVkZXMoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKCgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9ICgwLCBfZ2V0TmV4dFBhdGhuYW1lSW5mbykuZ2V0TmV4dFBhdGhuYW1lSW5mbygoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoc291cmNlKS5wYXRobmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhcyA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhcnNlZFNvdXJjZS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoYXMsIHBhZ2VzLCByZXdyaXRlcywgcGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgKHBhdGgpPT5yZXNvbHZlRHluYW1pY1JvdXRlKHBhdGgsIHBhZ2VzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubWF0Y2hlZFBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSByZXN1bHQucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcyA9IHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYWdlcy5pbmNsdWRlcyhmc1BhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZFBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShmc1BhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZFBhdGhuYW1lICE9PSBmc1BhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmc1BhdGhuYW1lID0gcmVzb2x2ZWRQYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkgPyByZXNvbHZlRHluYW1pY1JvdXRlKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aCgoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcykucGF0aG5hbWUsIHBhZ2VzKSA6IGZzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKCgwLCBfcm91dGVSZWdleCkuZ2V0Um91dGVSZWdleChyZXNvbHZlZEhyZWYpKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdyZXdyaXRlJyxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogJydcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZWRpcmVjdCcpO1xuICAgIGlmIChyZWRpcmVjdFRhcmdldCkge1xuICAgICAgICBpZiAocmVkaXJlY3RUYXJnZXQuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXROZXh0UGF0aG5hbWVJbmZvKS5mb3JtYXROZXh0UGF0aG5hbWVJbmZvKF9leHRlbmRzKHt9LCAoMCwgX2dldE5leHRQYXRobmFtZUluZm8pLmdldE5leHRQYXRobmFtZUluZm8oc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgICAgICBidWlsZElkOiAnJ1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3JlZGlyZWN0LWludGVybmFsJyxcbiAgICAgICAgICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgICAgICAgICAgIG5ld1VybDogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogcmVkaXJlY3RUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiAnbmV4dCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF93aXRoTWlkZGxld2FyZUVmZmVjdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF93aXRoTWlkZGxld2FyZUVmZmVjdHMoKSB7XG4gICAgX3dpdGhNaWRkbGV3YXJlRWZmZWN0cyA9IF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHlpZWxkIG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1hdGNoZXMgfHwgIW9wdGlvbnMuZmV0Y2hEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIG9wdGlvbnMuZmV0Y2hEYXRhKCk7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3QgPSB5aWVsZCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGEuZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBkYXRhLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIHRleHQ6IGRhdGEudGV4dCxcbiAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICBlZmZlY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAqIFRPRE86IFJldmlzaXQgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICAgICAqIEZvciBub3cgd2Ugd2lsbCBub3QgY29uc2lkZXIgbWlkZGxld2FyZSBkYXRhIGVycm9ycyB0byBiZSBmYXRhbC5cbiAgICAgKiBtYXliZSB3ZSBzaG91bGQgcmV2aXNpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAqLyByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfd2l0aE1pZGRsZXdhcmVFZmZlY3RzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5jb25zdCBtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04gJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gJ19fbmV4dCc7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZXF1ZW5jZXNcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWU7XG4gICAgfSBjYXRjaCAobikge31cbn0oKTtcbmNvbnN0IFNTR19EQVRBX05PVF9GT1VORCA9IFN5bWJvbCgnU1NHX0RBVEFfTk9UX0ZPVU5EJyk7XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCB7XG4gICAgICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgICAgICAvLyBDb29raWVzIG1heSBhbHNvIGJlIHJlcXVpcmVkIGZvciBgZ2V0U2VydmVyU2lkZVByb3BzYC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgICAgICAvLyA+IG9wdGlvbi5cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0ZldGNoX0FQSS9Vc2luZ19GZXRjaFxuICAgICAgICAvL1xuICAgICAgICAvLyA+IEZvciBtYXhpbXVtIGJyb3dzZXIgY29tcGF0aWJpbGl0eSB3aGVuIGl0IGNvbWVzIHRvIHNlbmRpbmcgJlxuICAgICAgICAvLyA+IHJlY2VpdmluZyBjb29raWVzLCBhbHdheXMgc3VwcGx5IHRoZSBgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidgXG4gICAgICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaCNjYXZlYXRzXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmhlYWRlcnMsIHtcbiAgICAgICAgICAgICd4LW5leHRqcy1kYXRhJzogJzEnXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YSh7IGRhdGFIcmVmICwgaW5mbGlnaHRDYWNoZSAsIGlzUHJlZmV0Y2ggLCBoYXNNaWRkbGV3YXJlICwgaXNTZXJ2ZXJSZW5kZXIgLCBwYXJzZUpTT04gLCBwZXJzaXN0Q2FjaGUgLCBpc0JhY2tncm91bmQgLCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgIH0pIHtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5ICB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgIHZhciByZWYxO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+e1xuICAgICAgICByZXR1cm4gZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiAncHJlZmV0Y2gnXG4gICAgICAgICAgICB9IDoge30sIGlzUHJlZmV0Y2ggJiYgaGFzTWlkZGxld2FyZSA/IHtcbiAgICAgICAgICAgICAgICAneC1taWRkbGV3YXJlLXByZWZldGNoJzogJzEnXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAocmVmMSA9IHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgIT0gbnVsbCA/IHJlZjEgOiAnR0VUJ1xuICAgICAgICB9KS50aGVuKChyZXNwb25zZSk9PntcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vayAmJiAocGFyYW1zID09IG51bGwgPyB2b2lkIDAgOiBwYXJhbXMubWV0aG9kKSA9PT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAganNvbjoge30sXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCkudGhlbigodGV4dCk9PntcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiB0aGUgZGF0YSByZXNwb25zZSBpcyBhIHJlZGlyZWN0IGJlY2F1c2Ugb2YgYSBtaWRkbGV3YXJlXG4gICAgICAgICAgICAgKiB3ZSBkbyBub3QgY29uc2lkZXIgaXQgYW4gZXJyb3IuIFRoZSBoZWFkZXJzIG11c3QgYnJpbmcgdGhlXG4gICAgICAgICAgICAgKiBtYXBwZWQgbG9jYXRpb24uXG4gICAgICAgICAgICAgKiBUT0RPOiBDaGFuZ2UgdGhlIHN0YXR1cyBjb2RlIGluIHRoZSBoYW5kbGVyLlxuICAgICAgICAgICAgICovIGlmIChoYXNNaWRkbGV3YXJlICYmIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwMixcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwNyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDMwOFxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc01pZGRsZXdhcmUgJiYgcmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlZiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiByZWYubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90Rm91bmQ6IFNTR19EQVRBX05PVF9GT1VORFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhc1xuICAgICAgICAgICAgICogY2F1c2VkIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvXG4gICAgICAgICAgICAgKiBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAgICAgICovIGlmICghaXNTZXJ2ZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfcm91dGVMb2FkZXIpLm1hcmtBc3NldEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIGpzb246IHBhcnNlSlNPTiA/IHRyeVRvUGFyc2VBc0pTT04odGV4dCkgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoIXBlcnNpc3RDYWNoZSB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICBpZiAoIXVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgvLyBjaHJvbWVcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnRmFpbGVkIHRvIGZldGNoJyB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gJ05ldHdvcmtFcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gZmV0Y2ggcmVzb3VyY2UuJyB8fCAvLyBzYWZhcmlcbiAgICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnTG9hZCBmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgKDAsIF9yb3V0ZUxvYWRlcikubWFya0Fzc2V0RXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxuICAgIC8vIGluZmxpZ2h0IGNhY2hlIHVudGlsIHN1Y2Nlc3NmdWwgZGF0YSByZXNwb25zZVxuICAgIC8vIHRoaXMgYWxsb3dzIHJhY2luZyBjbGljayBldmVudCB3aXRoIGZldGNoaW5nIG5ld2VyIGRhdGFcbiAgICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxuICAgIGlmICh1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgJiYgcGVyc2lzdENhY2hlKSB7XG4gICAgICAgIHJldHVybiBnZXREYXRhKHt9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBQcm9taXNlLnJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbmZsaWdodENhY2hlW2NhY2hlS2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldID0gZ2V0RGF0YShpc0JhY2tncm91bmQgPyB7XG4gICAgICAgIG1ldGhvZDogJ0hFQUQnXG4gICAgfSA6IHt9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleSgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgMTApO1xufVxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmwgLCByb3V0ZXIgIH0pIHtcbiAgICAvLyBlbnN1cmUgd2UgZG9uJ3QgdHJpZ2dlciBhIGhhcmQgbmF2aWdhdGlvbiB0byB0aGUgc2FtZVxuICAgIC8vIFVSTCBhcyB0aGlzIGNhbiBlbmQgdXAgd2l0aCBhbiBpbmZpbml0ZSByZWZyZXNoXG4gICAgaWYgKHVybCA9PT0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShyb3V0ZXIuYXNQYXRoLCByb3V0ZXIubG9jYWxlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCAke3VybH0gJHtsb2NhdGlvbi5ocmVmfWApO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbn1cbmNvbnN0IGdldENhbmNlbGxlZEhhbmRsZXIgPSAoeyByb3V0ZSAsIHJvdXRlciAgfSk9PntcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCIke3JvdXRlfVwiYCk7XG4gICAgICAgICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgICAgICAgcm91dGVyLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBoYW5kbGVDYW5jZWxsZWQ7XG59O1xuY2xhc3MgUm91dGVyIHtcbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi8gYmFjaygpIHtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkuYmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gZm9yd2FyZCBpbiBoaXN0b3J5XG4gICAqLyBmb3J3YXJkKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGBwdXNoU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcHVzaCh1cmwsIGFzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHNlbGYucGFnZVhPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICh7IHVybCAsIGFzICB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyByZXBsYWNlKHVybCwgYXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAoeyB1cmwgLCBhcyAgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCB1cmwsIGFzKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5nZSgncmVwbGFjZVN0YXRlJywgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIF9iZmwoYXMsIHJlc29sdmVkQXMsIGxvY2FsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbFN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY3VyQXMgb2YgW1xuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBc1xuICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaCA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChuZXcgVVJMKGN1ckFzLCAnaHR0cDovL24nKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2hMb2NhbGUgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKGFzTm9TbGFzaCwgbG9jYWxlIHx8IF90aGlzLmxvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKG5ldyBVUkwoX3RoaXMuYXNQYXRoLCAnaHR0cDovL24nKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmLCByZWYyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxTdGF0aWMgPSBtYXRjaGVzQmZsU3RhdGljIHx8ICEhKChyZWYgPSBfdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiByZWYuaGFzKGFzTm9TbGFzaCkpIHx8ICEhKChyZWYyID0gX3RoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMi5oYXMoYXNOb1NsYXNoTG9jYWxlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGhhcmQgbmF2aWdhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgIW1hdGNoZXNCZmxEeW5hbWljICYmIGkgPCBjdXJBc1BhcnRzLmxlbmd0aCArIDE7IGkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVmMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQYXJ0ID0gY3VyQXNQYXJ0cy5zbGljZSgwLCBpKS5qb2luKCcvJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBhcnQgJiYgKChyZWYzID0gX3RoaXMuX2JmbF9kKSA9PSBudWxsID8gdm9pZCAwIDogcmVmMy5oYXMoY3VycmVudFBhcnQpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY2xpZW50IHJvdXRlciBmaWx0ZXIgaXMgbWF0Y2hlZCB0aGVuIHdlIHRyaWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhcywgbG9jYWxlIHx8IF90aGlzLmxvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIF9hc3luY190b19nZW5lcmF0b3IoZnVuY3Rpb24qKCkge1xuICAgICAgICAgICAgaWYgKCEoMCwgX2lzTG9jYWxVcmwpLmlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qcyBjbGllbnQtc2lkZVxuICAgICAgICAgICAgLy8gaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS4gSXQgbWF5IGNoYW5nZSBhdFxuICAgICAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICBjb25zdCBpc1F1ZXJ5VXBkYXRpbmcgPSBvcHRpb25zLl9oID09PSAxO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5fYmZsKGFzLCB1bmRlZmluZWQsIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9IGlzUXVlcnlVcGRhdGluZyB8fCBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiB8fCAoMCwgX3BhcnNlUGF0aCkucGFyc2VQYXRoKHVybCkucGF0aG5hbWUgPT09ICgwLCBfcGFyc2VQYXRoKS5wYXJzZVBhdGgoYXMpLnBhdGhuYW1lO1xuICAgICAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIF90aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIGZvciBzdGF0aWMgcGFnZXMgd2l0aCBxdWVyeSBwYXJhbXMgaW4gdGhlIFVSTCB3ZSBkZWxheVxuICAgICAgICAgICAgLy8gbWFya2luZyB0aGUgcm91dGVyIHJlYWR5IHVudGlsIGFmdGVyIHRoZSBxdWVyeSBpcyB1cGRhdGVkXG4gICAgICAgICAgICAvLyBvciBhIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkXG4gICAgICAgICAgICBjb25zdCByZWFkeVN0YXRlQ2hhbmdlID0gX3RoaXMuaXNSZWFkeSAhPT0gdHJ1ZTtcbiAgICAgICAgICAgIF90aGlzLmlzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgaXNTc3IgPSBfdGhpcy5pc1NzcjtcbiAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGEgcm91dGUgdHJhbnNpdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIGJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgX3RoaXMuY2xjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJldkxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPSBvcHRpb25zLmxvY2FsZSA9PT0gZmFsc2UgPyBfdGhpcy5kZWZhdWx0TG9jYWxlIDogb3B0aW9ucy5sb2NhbGUgfHwgbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKCgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhcnNlZEFzLnBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChwYXJzZWRBcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKTtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKCgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKHVybCkgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aCh1cmwpIDogdXJsLCBfdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWY7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKHJlZiA9IF90aGlzLmxvY2FsZXMpID09IG51bGwgPyB2b2lkIDAgOiByZWYuaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9ICgwLCBfYWRkTG9jYWxlKS5hZGRMb2NhbGUocGFyc2VkQXMucGF0aG5hbWUsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiBiZXR0ZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdpdGggcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gKDAsIF9kZXRlY3REb21haW5Mb2NhbGUpLmRldGVjdERvbWFpbkxvY2FsZShfdGhpcy5kb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlkTmF2aWdhdGUgJiYgZGV0ZWN0ZWREb21haW4gJiYgX3RoaXMuaXNMb2NhbGVEb21haW4gJiYgc2VsZi5sb2NhdGlvbi5ob3N0bmFtZSAhPT0gZGV0ZWN0ZWREb21haW4uZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7ZGV0ZWN0ZWREb21haW4uZG9tYWlufSR7KDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoYCR7bmV4dFN0YXRlLmxvY2FsZSA9PT0gZGV0ZWN0ZWREb21haW4uZGVmYXVsdExvY2FsZSA/ICcnIDogYC8ke25leHRTdGF0ZS5sb2NhbGV9YH0ke2FzTm9CYXNlUGF0aCA9PT0gJy8nID8gJycgOiBhc05vQmFzZVBhdGh9YCB8fCAnLycpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZE5hdmlnYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGlkTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWFya2luZyByb3V0ZSBjaGFuZ2VzIGFzIGEgbmF2aWdhdGlvbiBzdGFydCBlbnRyeVxuICAgICAgICAgICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICAgICAgICAgIHBlcmZvcm1hbmNlLm1hcmsoJ3JvdXRlQ2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNoYWxsb3cgPWZhbHNlICwgc2Nyb2xsID10cnVlICB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHJvdXRlUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5faW5GbGlnaHRSb3V0ZSAmJiBfdGhpcy5jbGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzU3NyKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSwgX3RoaXMuX2luRmxpZ2h0Um91dGUsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jbGMoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXMgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKCgwLCBfaGFzQmFzZVBhdGgpLmhhc0Jhc2VQYXRoKGFzKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgX3RoaXMuZGVmYXVsdExvY2FsZSkpO1xuICAgICAgICAgICAgY29uc3QgY2xlYW5lZEFzID0gKDAsIF9yZW1vdmVMb2NhbGUpLnJlbW92ZUxvY2FsZSgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChhcykgPyAoMCwgX3JlbW92ZUJhc2VQYXRoKS5yZW1vdmVCYXNlUGF0aChhcykgOiBhcywgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICBfdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlQ2hhbmdlID0gcHJldkxvY2FsZSAhPT0gbmV4dFN0YXRlLmxvY2FsZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG4gICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyAmJiBfdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBcztcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ2hhc2hDaGFuZ2VTdGFydCcsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRoZSByZXNvbHZlZCBocmVmIHdoZW4gb25seSBhIGhhc2ggY2hhbmdlP1xuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvSGFzaChjbGVhbmVkQXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBfdGhpcy5zZXQobmV4dFN0YXRlLCBfdGhpcy5jb21wb25lbnRzW25leHRTdGF0ZS5yb3V0ZV0sIG51bGwpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUVycm9yJywgZXJyLCBjbGVhbmVkQXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAgICAgLy8gVGhlIGJ1aWxkIG1hbmlmZXN0IG5lZWRzIHRvIGJlIGxvYWRlZCBiZWZvcmUgYXV0by1zdGF0aWMgZHluYW1pYyBwYWdlc1xuICAgICAgICAgICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICAgICAgbGV0IHBhZ2VzLCByZXdyaXRlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzICB9XSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpLCBcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGZhaWwgdG8gcmVzb2x2ZSB0aGUgcGFnZSBsaXN0IG9yIGNsaWVudC1idWlsZCBtYW5pZmVzdCwgd2UgbXVzdFxuICAgICAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBhc2tlZCB0byBjaGFuZ2UgdGhlIGN1cnJlbnQgVVJMIHdlIHNob3VsZCByZWxvYWQgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgICAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgICAgICAgICAvLyBhcyB0aGlzIHNob3VsZCBub3QgZ28gaW50byB0aGUgaGlzdG9yeSAoVGhhdCdzIGhvdyBicm93c2VycyB3b3JrKVxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICAgICAgaWYgKCFfdGhpcy51cmxJc05ldyhjbGVhbmVkQXMpICYmICFsb2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSAncmVwbGFjZVN0YXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgICAgICAvLyBwYWdlcyB0byBhbGxvdyBidWlsZGluZyB0aGUgZGF0YSBVUkwgY29ycmVjdGx5XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzO1xuICAgICAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAgICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgICAgICAgICAgLy8gYmFzZVBhdGggZnJvbSB0aGUgcGF0aG5hbWUgdG8gbWF0Y2ggdGhlIHBhZ2VzIGRpciAxLXRvLTFcbiAgICAgICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2goKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICAgICAgbGV0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFzUGF0aG5hbWUgPSBhcy5zdGFydHNXaXRoKCcvJykgJiYgKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKGFzKS5wYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShwYXJzZWRBc1BhdGhuYW1lICYmIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmICghKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHJvdXRlKSB8fCAhKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcigoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSkpO1xuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgYXR0ZW1wdCByZXNvbHZlIGFzUGF0aCB3aGVuIHdlIG5lZWQgdG8gZXhlY3V0ZVxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBhcyB0aGUgcmVzb2x2aW5nIHdpbGwgb2NjdXIgc2VydmVyLXNpZGVcbiAgICAgICAgICAgIGNvbnN0IGlzTWlkZGxld2FyZU1hdGNoID0gIW9wdGlvbnMuc2hhbGxvdyAmJiAoeWllbGQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRSZXNvbHZlSHJlZiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLl9zaG91bGRSZXNvbHZlSHJlZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShjbGVhbmVkQXMsIG5leHRTdGF0ZS5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBxdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogX3RoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9IHJld3JpdGVzUmVzdWx0LmFzUGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyB0aGUgY29ycmVjdCBwYWdlIGNodW5rIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aChwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKDAsIF9pc0xvY2FsVXJsKS5pc0xvY2FsVVJMKGFzKSkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBocmVmOiBcIiR7dXJsfVwiIGFuZCBhczogXCIke2FzfVwiLCByZWNlaXZlZCByZWxhdGl2ZSBocmVmIGFuZCBleHRlcm5hbCBhc2AgKyBgXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlTG9jYWxlKS5yZW1vdmVMb2NhbGUoKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgcm91dGUgPSAoMCwgX3JlbW92ZVRyYWlsaW5nU2xhc2gpLnJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpO1xuICAgICAgICAgICAgbGV0IHJvdXRlTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzRHluYW1pYykuaXNEeW5hbWljUm91dGUocm91dGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwocmVzb2x2ZWRBcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocm91dGUpO1xuICAgICAgICAgICAgICAgIHJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlTWF0Y2hlcikuZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEludGVycG9sYXRlID0gcm91dGUgPT09IGFzUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZSA/ICgwLCBfaW50ZXJwb2xhdGVBcykuaW50ZXJwb2xhdGVBcyhyb3V0ZSwgYXNQYXRobmFtZSwgcXVlcnkpIDoge307XG4gICAgICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoKHBhcmFtKT0+IXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pc3NpbmdQYXJhbXMubGVuZ3RoID4gMCAmJiAhaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke3Nob3VsZEludGVycG9sYXRlID8gYEludGVycG9sYXRpbmcgaHJlZmAgOiBgTWlzbWF0Y2hpbmcgXFxgYXNcXGAgYW5kIFxcYGhyZWZcXGBgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICsgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKCcsICcpfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKHNob3VsZEludGVycG9sYXRlID8gYFRoZSBwcm92aWRlZCBcXGBocmVmXFxgICgke3VybH0pIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzICgke21pc3NpbmdQYXJhbXMuam9pbignLCAnKX0pIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gYCA6IGBUaGUgcHJvdmlkZWQgXFxgYXNcXGAgdmFsdWUgKCR7YXNQYXRobmFtZX0pIGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSBcXGBocmVmXFxgIHZhbHVlICgke3JvdXRlfSkuIGApICsgYFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvJHtzaG91bGRJbnRlcnBvbGF0ZSA/ICdocmVmLWludGVycG9sYXRpb24tZmFpbGVkJyA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcyd9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNob3VsZEludGVycG9sYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcnNlZEFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6ICgwLCBfb21pdCkub21pdChxdWVyeSwgaW50ZXJwb2xhdGVkQXMucGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVyZ2UgcGFyYW1zIGludG8gYHF1ZXJ5YCwgb3ZlcndyaXRpbmcgYW55IHNwZWNpZmllZCBpbiBzZWFyY2hcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0Vycm9yUm91dGUgPSBfdGhpcy5wYXRobmFtZSA9PT0gJy80MDQnIHx8IF90aGlzLnBhdGhuYW1lID09PSAnL19lcnJvcic7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZWY0LCByZWY1LCByZWY2O1xuICAgICAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IGlzTWlkZGxld2FyZU1hdGNoLFxuICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU6IG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIF90aGlzLl9iZmwoYXMsICdyZXNvbHZlZEFzJyBpbiByb3V0ZUluZm8gPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6IHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgncm91dGUnIGluIHJvdXRlSW5mbyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJvdXRlSW5mby5yb3V0ZSB8fCByb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcm91dGUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyb3V0ZVByb3BzLnNoYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGVJbmZvLnF1ZXJ5IHx8IHt9LCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xlYW5lZFBhcnNlZFBhdGhuYW1lID0gKDAsIF9oYXNCYXNlUGF0aCkuaGFzQmFzZVBhdGgocGFyc2VkLnBhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKHBhcnNlZC5wYXRobmFtZSkgOiBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHBhdGhuYW1lICE9PSBjbGVhbmVkUGFyc2VkUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHJvdXRlTWF0Y2gpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm91dGVNYXRjaCAmJiBxdWVyeVtrZXldID09PSByb3V0ZU1hdGNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkQXMgPSAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiAoMCwgX2FkZEJhc2VQYXRoKS5hZGRCYXNlUGF0aCgoMCwgX2FkZExvY2FsZSkuYWRkTG9jYWxlKG5ldyBVUkwoYXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2hhc0Jhc2VQYXRoKS5oYXNCYXNlUGF0aChyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV3cml0ZUFzID0gKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmV3cml0ZUFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUmVzdWx0ID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHJld3JpdGVBcywgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9IGxvY2FsZVJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSAoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyUm91dGVNYXRjaCA9ICgwLCBfcm91dGVNYXRjaGVyKS5nZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkobmV3IFVSTChyZXdyaXRlQXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgY3VyUm91dGVNYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJvdXRlSW5mbyBicmluZ3MgYSByZWRpcmVjdCB3ZSBzaW1wbHkgYXBwbHkgaXQuXG4gICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSAncmVkaXJlY3QtaW50ZXJuYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY2hhbmdlKG1ldGhvZCwgcm91dGVJbmZvLm5ld1VybCwgcm91dGVJbmZvLm5ld0FzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHJvdXRlSW5mby5kZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlSW5mby5Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQudW5zdGFibGVfc2NyaXB0TG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdHMgPSBbXS5jb25jYXQoY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3NjcmlwdCkuaGFuZGxlQ2xpZW50U2NyaXB0TG9hZChzY3JpcHQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIHJlZGlyZWN0IG9uIGNsaWVudC10cmFuc2l0aW9uXG4gICAgICAgICAgICAgICAgaWYgKChyb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUCkgJiYgcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2UgdGhlIGRlc3RpbmF0aW9uIGZyb20gcmVkaXJlY3Qgd2l0aG91dCBhZGRpbmcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmxvY2FsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjbGllbnQtbmF2aWdhdGlvbiBpZiBpdCBpcyBmYWxsaW5nIGJhY2sgdG8gaGFyZCBuYXZpZ2F0aW9uIGlmXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uLnN0YXJ0c1dpdGgoJy8nKSAmJiByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9ICgwLCBfcGFyc2VSZWxhdGl2ZVVybCkucGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSHJlZi5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGFyc2VkSHJlZi5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdXJsOiBuZXdVcmwgLCBhczogbmV3QXMgIH0gPSBwcmVwYXJlVXJsQXMoX3RoaXMsIGRlc3RpbmF0aW9uLCBkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmNoYW5nZShtZXRob2QsIG5ld1VybCwgbmV3QXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUuaXNQcmV2aWV3ID0gISFyb3V0ZUluZm8ucHJvcHMuX19OX1BSRVZJRVc7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbm90Rm91bmRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuZmV0Y2hDb21wb25lbnQoJy80MDQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy80MDQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnL19lcnJvcic7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVQcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJ3R5cGUnIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBfdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmNCA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY1ID0gcmVmNC5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiByZWY1LnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChyZWY2ID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmNi5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9yb3V0ZTtcbiAgICAgICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9IG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09ICgoX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlIDogcm91dGUpO1xuICAgICAgICAgICAgICAgIHZhciBfc2Nyb2xsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9IChfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfc2Nyb2xsIDogIWlzUXVlcnlVcGRhdGluZyAmJiAhaXNWYWxpZFNoYWxsb3dSb3V0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNldFNjcm9sbCA9IHNob3VsZFNjcm9sbCA/IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgIH0gOiBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgICAgIC8vIHRoZSBuZXcgc3RhdGUgdGhhdCB0aGUgcm91dGVyIGdvbm5hIHNldFxuICAgICAgICAgICAgICAgIGNvbnN0IHVwY29taW5nUm91dGVyU3RhdGUgPSBfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogY2xlYW5lZEFzLFxuICAgICAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAgICAgLy8gcXVlcnkgcGFyYW1ldGVycy4gUm91dGUgY2hhbmdlcyBoZXJlIG1pZ2h0IGFkZCB0aGUgYmFzZVBhdGggd2hlbiBpdFxuICAgICAgICAgICAgICAgIC8vIHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnQuIFRoaXMgaXMgYWxzbyB3aHkgdGhpcyBibG9jayBpcyBiZWZvcmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBVUkwpLlxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNFcnJvclJvdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWY3LCByZWY4LCByZWY5O1xuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSB5aWVsZCBfdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGU6IF90aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IF90aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhX3RoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAke190aGlzLnBhdGhuYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmICgocmVmNyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWY4ID0gcmVmNy5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiByZWY4LnN0YXR1c0NvZGUpID09PSA1MDAgJiYgKChyZWY5ID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogcmVmOS5wYWdlUHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuc3RhdHVzQ29kZSA9IDUwMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIGZvciBxdWVyeSB1cGRhdGVzIHdlIGNhbiBza2lwIGl0IGlmIHRoZSBzdGF0ZSBpcyB1bmNoYW5nZWQgYW5kIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvaXNzdWVzLzM3MTM5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuU2tpcFVwZGF0aW5nID0gaXNRdWVyeVVwZGF0aW5nICYmICF1cGNvbWluZ1Njcm9sbFN0YXRlICYmICFyZWFkeVN0YXRlQ2hhbmdlICYmICFsb2NhbGVDaGFuZ2UgJiYgKDAsIF9jb21wYXJlU3RhdGVzKS5jb21wYXJlUm91dGVyU3RhdGVzKHVwY29taW5nUm91dGVyU3RhdGUsIF90aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgX3RoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByb3V0ZUluZm8uZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQSBoYXNoIG1hcmsgIyBpcyB0aGUgb3B0aW9uYWwgbGFzdCBwYXJ0IG9mIGEgVVJMXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc2hSZWdleCA9IC8jLiskLztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNjcm9sbFRvSGFzaChhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIxKSB7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCBfaXNFcnJvcikuZGVmYXVsdChlcnIxKSAmJiBlcnIxLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgIT09ICdwdXNoU3RhdGUnIHx8ICgwLCBfdXRpbHMpLmdldFVSTCgpICE9PSBhcykge1xuICAgICAgICAgICAgdGhpcy5fc2hhbGxvdyA9IG9wdGlvbnMuc2hhbGxvdztcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oe1xuICAgICAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICAgIF9fTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuX2tleSA9IG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgICcnLCBhcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUm91dGVJbmZvRXJyb3IoZXJyLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9yb3V0ZUxvYWRlcikuaXNBc3NldEVycm9yKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyBhIGhhcmQgcmVsb2FkIGlzIHRoZSBwcm9wZXIgd2F5IHRvIGRlYWwgd2l0aCB0aGlzLlxuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgICAgICAgICAgIC8vIFNvIGxldCdzIHRocm93IGEgY2FuY2VsbGF0aW9uIGVycm9yIHN0b3AgdGhlIHJvdXRpbmcgbG9naWMuXG4gICAgICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQgLCBzdHlsZVNoZWV0cyAgfSA9IHlpZWxkIF90aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgZXJyLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0geWllbGQgX3RoaXMuZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogJywgZ2lwRXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgICAgICB9IGNhdGNoIChyb3V0ZUluZm9FcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc0Vycm9yKS5kZWZhdWx0KHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgJycpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZ2V0Um91dGVJbmZvKHsgcm91dGU6IHJlcXVlc3RlZFJvdXRlICwgcGF0aG5hbWUgLCBxdWVyeSAsIGFzICwgcmVzb2x2ZWRBcyAsIHJvdXRlUHJvcHMgLCBsb2NhbGUgLCBoYXNNaWRkbGV3YXJlICwgaXNQcmV2aWV3ICwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlICwgaXNRdWVyeVVwZGF0aW5nICwgaXNNaWRkbGV3YXJlUmV3cml0ZSAgfSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovIGxldCByb3V0ZSA9IHJlcXVlc3RlZFJvdXRlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVmLCByZWYxMCwgcmVmMTEsIHJlZjEyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiBfdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ0luZm8gPSBfdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICBpZiAocm91dGVQcm9wcy5zaGFsbG93ICYmIGV4aXN0aW5nSW5mbyAmJiBfdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY2FjaGVkUm91dGVJbmZvID0gZXhpc3RpbmdJbmZvICYmICEoJ2luaXRpYWwnIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgPyBleGlzdGluZ0luZm8gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNCYWNrZ3JvdW5kID0gaXNRdWVyeVVwZGF0aW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmOiBfdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBfdGhpcy5pc1NzcixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyBfdGhpcy5zYmMgOiBfdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IGlzUXVlcnlVcGRhdGluZyAmJiAhaXNNaWRkbGV3YXJlUmV3cml0ZSA/IG51bGwgOiB5aWVsZCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgaXQncyB1bi1uZWNlc3NhcnkgYW5kIGRvZXNuJ3QgbmVlZCB0byBiZSBmYXRhbFxuICAgICAgICAgICAgICAgICAgICAvLyB1bmxlc3MgaXQgaXMgYSBmYWxsYmFjayByb3V0ZSBhbmQgdGhlIHByb3BzIGNhbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKHJlZiA9IGRhdGEuZWZmZWN0KSA9PSBudWxsID8gdm9pZCAwIDogcmVmLnR5cGUpID09PSAncmVkaXJlY3QtaW50ZXJuYWwnIHx8IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAocmVmMTAgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZjEwLnR5cGUpID09PSAncmVkaXJlY3QtZXh0ZXJuYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmVmZmVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAocmVmMTEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHJlZjExLnR5cGUpID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZlVHJhaWxpbmdTbGFzaCkucmVtb3ZlVHJhaWxpbmdTbGFzaChkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWdlcyA9IHlpZWxkIF90aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAgICAgICAgICAgICAvLyBjYW4gYmUgcmV0dXJuZWQgYW5kIHRoaXMgc2hvdWxkIHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGUgPSByZXNvbHZlZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IF9leHRlbmRzKHt9LCBxdWVyeSwgZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlQmFzZVBhdGgpLnJlbW92ZUJhc2VQYXRoKCgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgX3RoaXMubG9jYWxlcykucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IF90aGlzLmNvbXBvbmVudHNbcm91dGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgX3RoaXMucm91dGUgPT09IHJvdXRlICYmICFoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hdGNoIHdpdGggdGhlIGN1cnJlbnQgcm91dGUgZHVlIHRvIHJld3JpdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGV4aXN0aW5nSW5mbywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzQXBpUm91dGUpLmlzQVBJUm91dGUocm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0gY2FjaGVkUm91dGVJbmZvIHx8ICh5aWVsZCBfdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRlZmF1bHQgZXhwb3J0IGlzIG5vdCBhIFJlYWN0IENvbXBvbmVudCBpbiBwYWdlOiBcIiR7cGF0aG5hbWV9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB3YXNCYWlsZWRQcmVmZXRjaCA9IGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IChyZWYxMiA9IGRhdGEucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiByZWYxMi5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLXNraXAnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRGZXRjaERhdGEgPSByb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUDtcbiAgICAgICAgICAgICAgICAvLyBGb3Igbm9uLVNTRyBwcmVmZXRjaGVzIHRoYXQgYmFpbGVkIGJlZm9yZSBzZW5kaW5nIGRhdGFcbiAgICAgICAgICAgICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxuICAgICAgICAgICAgICAgIGlmICh3YXNCYWlsZWRQcmVmZXRjaCAmJiAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNkY1tkYXRhLmRhdGFIcmVmXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwcm9wcyAsIGNhY2hlS2V5ICB9ID0geWllbGQgX3RoaXMuX2dldERhdGEoX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5qc29uKSAmJiAhd2FzQmFpbGVkUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGRhdGEuanNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhSHJlZiA9IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmKSA/IGRhdGEuZGF0YUhyZWYgOiBfdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBocmVmOiAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoZWQgPSB5aWVsZCBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogX3RoaXMuaXNTc3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiBfdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBmZXRjaGVkLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHM6IHlpZWxkIF90aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IF90aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExvY2FsZTogX3RoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXG4gICAgICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAgICAgLy8geC1taWRkbGV3YXJlLWNhY2hlOiBuby1jYWNoZSBhcyB3ZWxsXG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYgJiYgY2FjaGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLnNkY1tjYWNoZUtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnICYmICFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hOZXh0RGF0YShPYmplY3QuYXNzaWduKHt9LCBmZXRjaE5leHREYXRhUGFyYW1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogX3RoaXMuc2JjXG4gICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaCgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5yb3V0ZSA9IHJvdXRlO1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBcztcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgICAgICByZXR1cm4gcm91dGVJbmZvO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZVJvdXRlSW5mb0Vycm9yKCgwLCBfaXNFcnJvcikuZ2V0UHJvcGVyRXJyb3IoZXJyKSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgfVxuICAgIHNldChzdGF0ZSwgZGF0YSwgcmVzZXRTY3JvbGwpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoZGF0YSwgdGhpcy5jb21wb25lbnRzWycvX2FwcCddLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJyk7XG4gICAgICAgIGNvbnN0IFtuZXdVcmxOb0hhc2gsIG5ld0hhc2hdID0gYXMuc3BsaXQoJyMnKTtcbiAgICAgICAgLy8gTWFrZXMgc3VyZSB3ZSBzY3JvbGwgdG8gdGhlIHByb3ZpZGVkIGhhc2ggaWYgdGhlIHVybC9oYXNoIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgICAgIGlmIChvbGRVcmxOb0hhc2ggIT09IG5ld1VybE5vSGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgICAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgICAgIC8vIGxlYXZlIGhhc2ggPT09ICcnIGNhc2VzLiBUaGUgaWRlbnRpdHkgY2FzZSBmYWxscyB0aHJvdWdoXG4gICAgICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoO1xuICAgIH1cbiAgICBzY3JvbGxUb0hhc2goYXMpIHtcbiAgICAgICAgY29uc3QgWywgaGFzaCA9ICcnXSA9IGFzLnNwbGl0KCcjJyk7XG4gICAgICAgIC8vIFNjcm9sbCB0byB0b3AgaWYgdGhlIGhhc2ggaXMganVzdCBgI2Agd2l0aCBubyB2YWx1ZSBvciBgI3RvcGBcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGlmIChoYXNoID09PSAnJyB8fCBoYXNoID09PSAndG9wJykge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVTbW9vdGhTY3JvbGwpLmhhbmRsZVNtb290aFNjcm9sbCgoKT0+d2luZG93LnNjcm9sbFRvKDAsIDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWNvZGUgaGFzaCB0byBtYWtlIG5vbi1sYXRpbiBhbmNob3Igd29ya3MuXG4gICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgICAgIGNvbnN0IGlkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyYXdIYXNoKTtcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICgwLCBfaGFuZGxlU21vb3RoU2Nyb2xsKS5oYW5kbGVTbW9vdGhTY3JvbGwoKCk9PmlkRWwuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBjb25zdCBuYW1lRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShyYXdIYXNoKVswXTtcbiAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgKDAsIF9oYW5kbGVTbW9vdGhTY3JvbGwpLmhhbmRsZVNtb290aFNjcm9sbCgoKT0+bmFtZUVsLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVybElzTmV3KGFzUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1BhdGggIT09IGFzUGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAqIFByZWZldGNoIHBhZ2UgY29kZSwgeW91IG1heSB3YWl0IGZvciB0aGUgZGF0YSBkdXJpbmcgcGFnZSByZW5kZXJpbmcuXG4gICAqIFRoaXMgZmVhdHVyZSBvbmx5IHdvcmtzIGluIHByb2R1Y3Rpb24hXG4gICAqIEBwYXJhbSB1cmwgdGhlIGhyZWYgb2YgcHJlZmV0Y2hlZCBwYWdlXG4gICAqIEBwYXJhbSBhc1BhdGggdGhlIGFzIHBhdGggb2YgdGhlIHByZWZldGNoZWQgcGFnZVxuICAgKi8gcHJlZmV0Y2godXJsLCBhc1BhdGggPSB1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoMCwgX2lzQm90KS5pc0JvdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBwcmVmZXRjaGVzIGZvciBib3RzIHRoYXQgcmVuZGVyIHRoZSBsaW5rIHNpbmNlIHRoZXkgYXJlIHR5cGljYWxseSBuYXZpZ2F0aW5nXG4gICAgICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXG4gICAgICAgICAgICAgICAgLy8gcHJlZmV0Y2hlcy5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGFyc2VkID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgICAgICBsZXQgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gcGFyc2VkO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9ub3JtYWxpemVMb2NhbGVQYXRoKS5ub3JtYWxpemVMb2NhbGVQYXRoKHBhdGhuYW1lLCBfdGhpcy5sb2NhbGVzKS5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkQXMgPSAoMCwgX3BhcnNlUmVsYXRpdmVVcmwpLnBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplTG9jYWxlUGF0aCkubm9ybWFsaXplTG9jYWxlUGF0aChwYXJzZWRBcy5wYXRobmFtZSwgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gbG9jYWxlUGF0aFJlc3VsdC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IF90aGlzLmRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aCA9ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbihwYXJzZWRBcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFnZXMgPSB5aWVsZCBfdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZSA9IHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiBfdGhpcy5sb2NhbGU7XG4gICAgICAgICAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9IHlpZWxkIG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZXM7XG4gICAgICAgICAgICAgICAgKHsgX19yZXdyaXRlczogcmV3cml0ZXMgIH0gPSB5aWVsZCAoMCwgX3JvdXRlTG9hZGVyKS5nZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJld3JpdGVzUmVzdWx0ID0gKDAsIF9yZXNvbHZlUmV3cml0ZXMpLmRlZmF1bHQoKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgoKDAsIF9hZGRMb2NhbGUpLmFkZExvY2FsZShhc1BhdGgsIF90aGlzLmxvY2FsZSksIHRydWUpLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZC5xdWVyeSwgKHApPT5yZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSwgX3RoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyA9ICgwLCBfcmVtb3ZlTG9jYWxlKS5yZW1vdmVMb2NhbGUoKDAsIF9yZW1vdmVCYXNlUGF0aCkucmVtb3ZlQmFzZVBhdGgocmV3cml0ZXNSZXN1bHQuYXNQYXRoKSwgX3RoaXMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNEeW5hbWljKS5pc0R5bmFtaWNSb3V0ZShwYXJzZWQucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgKDAsIF9yb3V0ZU1hdGNoZXIpLmdldFJvdXRlTWF0Y2hlcigoMCwgX3JvdXRlUmVnZXgpLmdldFJvdXRlUmVnZXgocGFyc2VkLnBhdGhuYW1lKSkoKDAsIF9wYXJzZVBhdGgpLnBhcnNlUGF0aChhc1BhdGgpLnBhdGhuYW1lKSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09ICdzdHJpY3QnID8gbnVsbCA6IHlpZWxkIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyh7XG4gICAgICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKT0+ZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogX3RoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHJlZjogKDAsIF9mb3JtYXRVcmwpLmZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IF90aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogX3RoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhX3RoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIHdhcyBhIHJld3JpdGUgd2UgYXBwbHkgdGhlIGVmZmVjdHMgb2YgdGhlIHJld3JpdGUgb24gdGhlXG4gICAgICogY3VycmVudCBwYXJhbWV0ZXJzIGZvciB0aGUgcHJlZmV0Y2guXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09ICdyZXdyaXRlJykge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IF9leHRlbmRzKHt9LCBxdWVyeSwgZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSBkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gJ3JlZGlyZWN0LWV4dGVybmFsJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKTtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpPT57XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1NzZyA/IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZiA6IF90aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogX3RoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhX3RoaXMuaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZTogb3B0aW9ucy51bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUgfHwgb3B0aW9ucy5wcmlvcml0eSAmJiAhIXByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlTVElDX0NMSUVOVF9DQUNIRVxuICAgICAgICAgICAgICAgICAgICB9KS50aGVuKCgpPT5mYWxzZSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLCBcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9KSgpO1xuICAgIH1cbiAgICBmZXRjaENvbXBvbmVudChyb3V0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gX2FzeW5jX3RvX2dlbmVyYXRvcihmdW5jdGlvbiooKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IF90aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9uZW50UmVzdWx0ID0geWllbGQgX3RoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudFJlc3VsdDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0xvYWRpbmcgaW5pdGlhbCBwcm9wcyBjYW5jZWxsZWQnKTtcbiAgICAgICAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRGbGlnaHREYXRhKGRhdGFIcmVmKSB7XG4gICAgICAgIC8vIERvIG5vdCBjYWNoZSBSU0MgZmxpZ2h0IHJlc3BvbnNlIHNpbmNlIGl0J3Mgbm90IGEgc3RhdGljIHJlc291cmNlXG4gICAgICAgIHJldHVybiBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRydWUsXG4gICAgICAgICAgICBwYXJzZUpTT046IGZhbHNlLFxuICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICBwZXJzaXN0Q2FjaGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2VcbiAgICAgICAgfSkudGhlbigoeyB0ZXh0ICB9KT0+KHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxQcm9wcyhDb21wb25lbnQsIGN0eCkge1xuICAgICAgICBjb25zdCB7IENvbXBvbmVudDogQXBwICB9ID0gdGhpcy5jb21wb25lbnRzWycvX2FwcCddO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzKS5sb2FkR2V0SW5pdGlhbFByb3BzKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lMSwgcXVlcnkxLCBhczEsIHsgaW5pdGlhbFByb3BzICwgcGFnZUxvYWRlciAsIEFwcCAsIHdyYXBBcHAgLCBDb21wb25lbnQgLCBlcnIgLCBzdWJzY3JpcHRpb24gLCBpc0ZhbGxiYWNrICwgbG9jYWxlICwgbG9jYWxlcyAsIGRlZmF1bHRMb2NhbGUgLCBkb21haW5Mb2NhbGVzICwgaXNQcmV2aWV3ICB9KXtcbiAgICAgICAgLy8gU2VydmVyIERhdGEgQ2FjaGUgKGZ1bGwgZGF0YSByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zZGMgPSB7fTtcbiAgICAgICAgLy8gU2VydmVyIEJhY2tncm91bmQgQ2FjaGUgKEhFQUQgcmVxdWVzdHMpXG4gICAgICAgIHRoaXMuc2JjID0ge307XG4gICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9rZXkgPSBjcmVhdGVLZXkoKTtcbiAgICAgICAgdGhpcy5vblBvcFN0YXRlID0gKGUpPT57XG4gICAgICAgICAgICBjb25zdCB7IGlzRmlyc3RQb3BTdGF0ZUV2ZW50ICB9ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuaXNGaXJzdFBvcFN0YXRlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gZS5zdGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgICAgICAgICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgICAgICAgICAgICAvLyAgMi4gV2hlbiB0aGUgVVJMIGNoYW5nZWQgd2l0aCAjXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgICAgICAgICAgIC8vIChhcyBpdCdzIGFscmVhZHkgY2hhbmdlZClcbiAgICAgICAgICAgICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAgICAgICAgICAgLy8gU28sIGRvaW5nIHRoZSBmb2xsb3dpbmcgZm9yICgxKSBkb2VzIG5vIGhhcm0uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYXRobmFtZSAsIHF1ZXJ5ICB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKCdyZXBsYWNlU3RhdGUnLCAoMCwgX2Zvcm1hdFVybCkuZm9ybWF0V2l0aFZhbGlkYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBxdWVyeVxuICAgICAgICAgICAgICAgIH0pLCAoMCwgX3V0aWxzKS5nZXRVUkwoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgICAgICAgICAgaWYgKHN0YXRlLl9fTkEpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdGF0ZS5fX04pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYWZhcmkgZmlyZXMgcG9wc3RhdGVldmVudCB3aGVuIHJlb3BlbmluZyB0aGUgYnJvd3Nlci5cbiAgICAgICAgICAgIGlmIChpc0ZpcnN0UG9wU3RhdGVFdmVudCAmJiB0aGlzLmxvY2FsZSA9PT0gc3RhdGUub3B0aW9ucy5sb2NhbGUgJiYgc3RhdGUuYXMgPT09IHRoaXMuYXNQYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZvcmNlZFNjcm9sbDtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJsICwgYXMgLCBvcHRpb25zICwga2V5ICB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc2VsZi5wYWdlWE9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIG9sZCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKCdfX25leHRfc2Nyb2xsXycgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2Uodik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lICB9ID0gKDAsIF9wYXJzZVJlbGF0aXZlVXJsKS5wYXJzZVJlbGF0aXZlVXJsKHVybCk7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAgICAgICAgIC8vIGNhbiBiZSBjYXVzZWQgYnkgbmF2aWdhdGluZyBiYWNrIGZyb20gYW4gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNTc3IgJiYgYXMgPT09ICgwLCBfYWRkQmFzZVBhdGgpLmFkZEJhc2VQYXRoKHRoaXMuYXNQYXRoKSAmJiBwYXRobmFtZSA9PT0gKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgodGhpcy5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgICAgICAgICAvLyBUaGV5IHdpbGwgdGhlbiBiZSByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIGV2ZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX2JwcyAmJiAhdGhpcy5fYnBzKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgc2hhbGxvdzogb3B0aW9ucy5zaGFsbG93ICYmIHRoaXMuX3NoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlOiBvcHRpb25zLmxvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xuICAgICAgICAgICAgICAgIF9oOiAwXG4gICAgICAgICAgICB9KSwgZm9yY2VkU2Nyb2xsKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmVUcmFpbGluZ1NsYXNoKS5yZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lMSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZTEgIT09ICcvX2Vycm9yJykge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHtcbiAgICAgICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcm9wczogaW5pdGlhbFByb3BzLFxuICAgICAgICAgICAgICAgIGVycixcbiAgICAgICAgICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgICAgICAgICAgX19OX1NTUDogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NQXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciAgfSA9IHJlcXVpcmUoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRpY0ZpbHRlckRhdGEgPSBwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9TX0ZJTFRFUjtcbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVI7XG4gICAgICAgICAgICBpZiAoc3RhdGljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGljRmlsdGVyRGF0YS5oYXNoZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcyA9IG5ldyBCbG9vbUZpbHRlcihzdGF0aWNGaWx0ZXJEYXRhLnNpemUsIHN0YXRpY0ZpbHRlckRhdGEuaGFzaGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iZmxfcy5pbXBvcnQoc3RhdGljRmlsdGVyRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZHluYW1pY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGR5bmFtaWNGaWx0ZXJEYXRhLmhhc2hlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9kID0gbmV3IEJsb29tRmlsdGVyKGR5bmFtaWNGaWx0ZXJEYXRhLnNpemUsIGR5bmFtaWNGaWx0ZXJEYXRhLmhhc2hlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc0R5bmFtaWMpLmlzRHluYW1pY1JvdXRlKHBhdGhuYW1lMSkgJiYgc2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQ7XG4gICAgICAgIHRoaXMuYmFzZVBhdGggPSBwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIHx8ICcnO1xuICAgICAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgdGhpcy5jbGMgPSBudWxsO1xuICAgICAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcDtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgICAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgICAgICB0aGlzLmlzU3NyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzUmVhZHkgPSAhIShzZWxmLl9fTkVYVF9EQVRBX18uZ3NzcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8IHNlbGYuX19ORVhUX0RBVEFfXy5hcHBHaXAgJiYgIXNlbGYuX19ORVhUX0RBVEFfXy5nc3AgfHwgIWF1dG9FeHBvcnREeW5hbWljICYmICFzZWxmLmxvY2F0aW9uLnNlYXJjaCAmJiAhcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgIHRoaXMuZG9tYWluTG9jYWxlcyA9IGRvbWFpbkxvY2FsZXM7XG4gICAgICAgICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISEoMCwgX2RldGVjdERvbWFpbkxvY2FsZSkuZGV0ZWN0RG9tYWluTG9jYWxlKGRvbWFpbkxvY2FsZXMsIHNlbGYubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHBhdGhuYW1lOiBwYXRobmFtZTEsXG4gICAgICAgICAgICBxdWVyeTogcXVlcnkxLFxuICAgICAgICAgICAgYXNQYXRoOiBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lMSA6IGFzMSxcbiAgICAgICAgICAgIGlzUHJldmlldzogISFpc1ByZXZpZXcsXG4gICAgICAgICAgICBsb2NhbGU6IHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQgPyBsb2NhbGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0ZhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFhczEuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgICAgICAgICAgIC8vIGluIG9yZGVyIGZvciBgZS5zdGF0ZWAgdG8gd29yayBvbiB0aGUgYG9ucG9wc3RhdGVgIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byByZWdpc3RlciB0aGUgaW5pdGlhbCByb3V0ZSB1cG9uIGluaXRpYWxpemF0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBhc1BhdGggPSAoMCwgX3V0aWxzKS5nZXRVUkwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoXG4gICAgICAgICAgICAgICAgfSkudGhlbigobWF0Y2hlcyk9PntcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSBhczEgIT09IHBhdGhuYW1lMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZSgncmVwbGFjZVN0YXRlJywgbWF0Y2hlcyA/IGFzUGF0aCA6ICgwLCBfZm9ybWF0VXJsKS5mb3JtYXRXaXRoVmFsaWRhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogKDAsIF9hZGRCYXNlUGF0aCkuYWRkQmFzZVBhdGgocGF0aG5hbWUxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBxdWVyeTFcbiAgICAgICAgICAgICAgICAgICAgfSksIGFzUGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gJ21hbnVhbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuUm91dGVyLmV2ZW50cyA9ICgwLCBfbWl0dCkuZGVmYXVsdCgpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUm91dGVyO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWF0Y2hlc01pZGRsZXdhcmUiLCJjcmVhdGVLZXkiLCJkZWZhdWx0IiwiX2FzeW5jX3RvX2dlbmVyYXRvciIsInJlcXVpcmUiLCJfZXh0ZW5kcyIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfcmVtb3ZlVHJhaWxpbmdTbGFzaCIsIl9yb3V0ZUxvYWRlciIsIl9zY3JpcHQiLCJfaXNFcnJvciIsIl9kZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiX25vcm1hbGl6ZUxvY2FsZVBhdGgiLCJfbWl0dCIsIl91dGlscyIsIl9pc0R5bmFtaWMiLCJfcGFyc2VSZWxhdGl2ZVVybCIsIl9yZXNvbHZlUmV3cml0ZXMiLCJfcm91dGVNYXRjaGVyIiwiX3JvdXRlUmVnZXgiLCJfZm9ybWF0VXJsIiwiX2RldGVjdERvbWFpbkxvY2FsZSIsIl9wYXJzZVBhdGgiLCJfYWRkTG9jYWxlIiwiX3JlbW92ZUxvY2FsZSIsIl9yZW1vdmVCYXNlUGF0aCIsIl9hZGRCYXNlUGF0aCIsIl9oYXNCYXNlUGF0aCIsIl9pc0FwaVJvdXRlIiwiX2dldE5leHRQYXRobmFtZUluZm8iLCJfZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsIl9jb21wYXJlU3RhdGVzIiwiX2lzTG9jYWxVcmwiLCJfaXNCb3QiLCJfb21pdCIsIl9yZXNvbHZlSHJlZiIsIl9pbnRlcnBvbGF0ZUFzIiwiX2hhbmRsZVNtb290aFNjcm9sbCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJfbWF0Y2hlc01pZGRsZXdhcmUiLCJhcHBseSIsImFyZ3VtZW50cyIsIm1hdGNoZXJzIiwiYXNQYXRobmFtZSIsImNsZWFuZWRBcyIsImFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyb3V0ZXIiLCJwYWdlTG9hZGVyIiwiZ2V0TWlkZGxld2FyZSIsInBhcnNlUGF0aCIsImFzUGF0aCIsInBhdGhuYW1lIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImFkZEJhc2VQYXRoIiwiYWRkTG9jYWxlIiwibG9jYWxlIiwic29tZSIsIm0iLCJSZWdFeHAiLCJyZWdleHAiLCJ0ZXN0Iiwic3RyaXBPcmlnaW4iLCJ1cmwiLCJvcmlnaW4iLCJnZXRMb2NhdGlvbk9yaWdpbiIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJsZW5ndGgiLCJwcmVwYXJlVXJsQXMiLCJhcyIsInJlc29sdmVIcmVmIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsImhyZWZXYXNBYnNvbHV0ZSIsImFzV2FzQWJzb2x1dGUiLCJwcmVwYXJlZFVybCIsInByZXBhcmVkQXMiLCJyZXNvbHZlRHluYW1pY1JvdXRlIiwicGFnZXMiLCJjbGVhblBhdGhuYW1lIiwicmVtb3ZlVHJhaWxpbmdTbGFzaCIsImRlbm9ybWFsaXplUGFnZVBhdGgiLCJpbmNsdWRlcyIsInBhZ2UiLCJpc0R5bmFtaWNSb3V0ZSIsImdldFJvdXRlUmVnZXgiLCJyZSIsImdldE1pZGRsZXdhcmVEYXRhIiwic291cmNlIiwicmVzcG9uc2UiLCJuZXh0Q29uZmlnIiwiYmFzZVBhdGgiLCJpMThuIiwibG9jYWxlcyIsInRyYWlsaW5nU2xhc2giLCJCb29sZWFuIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9UUkFJTElOR19TTEFTSCIsInJld3JpdGVIZWFkZXIiLCJoZWFkZXJzIiwiZ2V0IiwicmV3cml0ZVRhcmdldCIsIm1hdGNoZWRQYXRoIiwiX19ORVhUX0VYVEVSTkFMX01JRERMRVdBUkVfUkVXUklURV9SRVNPTFZFIiwicGFyc2VkUmV3cml0ZVRhcmdldCIsInBhcnNlUmVsYXRpdmVVcmwiLCJwYXRobmFtZUluZm8iLCJnZXROZXh0UGF0aG5hbWVJbmZvIiwicGFyc2VEYXRhIiwiZnNQYXRobmFtZSIsImFsbCIsImdldFBhZ2VMaXN0IiwiZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCIsInRoZW4iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInJlc3VsdCIsInF1ZXJ5IiwicGF0aCIsIm1hdGNoZWRQYWdlIiwicGFyc2VkQXMiLCJyZXNvbHZlZFBhdGhuYW1lIiwibWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInR5cGUiLCJzcmMiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJkZXN0aW5hdGlvbiIsImhhc2giLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiX3dpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImRhdGEiLCJlZmZlY3QiLCJlIiwiZmV0Y2hEYXRhIiwiZGF0YUhyZWYiLCJqc29uIiwidGV4dCIsImNhY2hlS2V5IiwibWFudWFsU2Nyb2xsUmVzdG9yYXRpb24iLCJfX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OIiwid2luZG93IiwiaGlzdG9yeSIsInYiLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwibiIsIlNTR19EQVRBX05PVF9GT1VORCIsIlN5bWJvbCIsImZldGNoUmV0cnkiLCJhdHRlbXB0cyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJtZXRob2QiLCJvayIsInN0YXR1cyIsInRyeVRvUGFyc2VBc0pTT04iLCJKU09OIiwicGFyc2UiLCJlcnJvciIsImZldGNoTmV4dERhdGEiLCJpbmZsaWdodENhY2hlIiwiaXNQcmVmZXRjaCIsImhhc01pZGRsZXdhcmUiLCJpc1NlcnZlclJlbmRlciIsInBhcnNlSlNPTiIsInBlcnNpc3RDYWNoZSIsImlzQmFja2dyb3VuZCIsInVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsInJlZjEiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsInJlZiIsIm5vdEZvdW5kIiwibWFya0Fzc2V0RXJyb3IiLCJjYXRjaCIsImVyciIsIm1lc3NhZ2UiLCJ1bmRlZmluZWQiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImhhbmRsZUhhcmROYXZpZ2F0aW9uIiwiZ2V0Q2FuY2VsbGVkSGFuZGxlciIsInJvdXRlIiwiY2FuY2VsIiwiY2xjIiwiaGFuZGxlQ2FuY2VsbGVkIiwiUm91dGVyIiwicGF0aG5hbWUxIiwicXVlcnkxIiwiYXMxIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3Iiwic2RjIiwic2JjIiwiaXNGaXJzdFBvcFN0YXRlRXZlbnQiLCJfa2V5Iiwib25Qb3BTdGF0ZSIsInN0YXRlIiwiY2hhbmdlU3RhdGUiLCJmb3JtYXRXaXRoVmFsaWRhdGlvbiIsImdldFVSTCIsIl9fTkEiLCJyZWxvYWQiLCJfX04iLCJmb3JjZWRTY3JvbGwiLCJrZXkiLCJzdHJpbmdpZnkiLCJ4Iiwic2VsZiIsInBhZ2VYT2Zmc2V0IiwieSIsInBhZ2VZT2Zmc2V0IiwiZ2V0SXRlbSIsImUxIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwiaGFzaGVzIiwiX2JmbF9zIiwic2l6ZSIsImltcG9ydCIsIl9iZmxfZCIsImV2ZW50cyIsImF1dG9FeHBvcnREeW5hbWljIiwiX19ORVhUX0RBVEFfXyIsImF1dG9FeHBvcnQiLCJfX05FWFRfUk9VVEVSX0JBU0VQQVRIIiwic3ViIiwiX3dyYXBBcHAiLCJpc0xvY2FsZURvbWFpbiIsImlzUmVhZHkiLCJnc3NwIiwiZ2lwIiwiYXBwR2lwIiwiZ3NwIiwic2VhcmNoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsImRldGVjdERvbWFpbkxvY2FsZSIsImhvc3RuYW1lIiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJfc2hvdWxkUmVzb2x2ZUhyZWYiLCJhZGRFdmVudExpc3RlbmVyIiwic2Nyb2xsUmVzdG9yYXRpb24iLCJiYWNrIiwiZm9yd2FyZCIsInB1c2giLCJyZXBsYWNlIiwiX2JmbCIsIl90aGlzIiwibWF0Y2hlc0JmbFN0YXRpYyIsIm1hdGNoZXNCZmxEeW5hbWljIiwiY3VyQXMiLCJhc05vU2xhc2giLCJhc05vU2xhc2hMb2NhbGUiLCJyZWYyIiwibm9ybWFsaXplZEFTIiwiY3VyQXNQYXJ0cyIsImkiLCJyZWYzIiwiY3VycmVudFBhcnQiLCJoYXMiLCJzcGxpdCIsImpvaW4iLCJpc1F1ZXJ5VXBkYXRpbmciLCJzaG91bGRSZXNvbHZlSHJlZiIsIm5leHRTdGF0ZSIsInJlYWR5U3RhdGVDaGFuZ2UiLCJwcmV2TG9jYWxlIiwibG9jYWxlUGF0aFJlc3VsdCIsImRpZE5hdmlnYXRlIiwiZGV0ZWN0ZWREb21haW4iLCJhc05vQmFzZVBhdGgiLCJzY3JvbGwiLCJyb3V0ZVByb3BzIiwibG9jYWxlQ2hhbmdlIiwicGFyc2VkIiwicGFyc2VkQXNQYXRobmFtZSIsImlzTWlkZGxld2FyZVJld3JpdGUiLCJpc01pZGRsZXdhcmVNYXRjaCIsInJld3JpdGVzUmVzdWx0Iiwicm91dGVNYXRjaCIsInJvdXRlUmVnZXgiLCJzaG91bGRJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZEFzIiwibWlzc2luZ1BhcmFtcyIsImlzRXJyb3JSb3V0ZSIsInJlZjQiLCJyZWY1IiwicmVmNiIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50Iiwic2NyaXB0cyIsInBhcnNlZEhyZWYiLCJub3RGb3VuZFJvdXRlIiwiXyIsIl9yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfc2Nyb2xsIiwic2hvdWxkU2Nyb2xsIiwicmVzZXRTY3JvbGwiLCJ1cGNvbWluZ1Njcm9sbFN0YXRlIiwidXBjb21pbmdSb3V0ZXJTdGF0ZSIsInJlZjciLCJyZWY4IiwicmVmOSIsImNhblNraXBVcGRhdGluZyIsImhhc2hSZWdleCIsImVycjEiLCJpc0xvY2FsVVJMIiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJodHRwIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJfaW5GbGlnaHRSb3V0ZSIsImVtaXQiLCJyZW1vdmVMb2NhbGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJzY3JvbGxUb0hhc2giLCJzZXQiLCJ1cmxJc05ldyIsInAiLCJleHRlcm5hbERlc3QiLCJpbnRlcnBvbGF0ZUFzIiwia2V5cyIsImdyb3VwcyIsImZpbHRlciIsInBhcmFtIiwib3B0aW9uYWwiLCJjb25zb2xlIiwid2FybiIsIm9taXQiLCJnZXRSb3V0ZUluZm8iLCJmb3JFYWNoIiwidW5zdGFibGVfc2NyaXB0TG9hZGVyIiwiY29uY2F0Iiwic2NyaXB0IiwiaGFuZGxlQ2xpZW50U2NyaXB0TG9hZCIsInBhZ2VQcm9wcyIsIl9fTl9SRURJUkVDVCIsIl9fTl9SRURJUkVDVF9CQVNFX1BBVEgiLCJfX05fUFJFVklFVyIsImZldGNoQ29tcG9uZW50Iiwic3RhdHVzQ29kZSIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJyZXF1ZXN0ZWRSb3V0ZSIsInJlZjEwIiwicmVmMTEiLCJyZWYxMiIsImV4aXN0aW5nSW5mbyIsImNhY2hlZFJvdXRlSW5mbyIsImZldGNoTmV4dERhdGFQYXJhbXMiLCJyZXNvbHZlZFJvdXRlIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwid2FzQmFpbGVkUHJlZmV0Y2giLCJzaG91bGRGZXRjaERhdGEiLCJnZXREYXRhSHJlZiIsInNraXBJbnRlcnBvbGF0aW9uIiwiaXNBUElSb3V0ZSIsInJlcyIsIm1vZCIsIl9nZXREYXRhIiwiZmV0Y2hlZCIsImdldFByb3BlckVycm9yIiwiYmVmb3JlUG9wU3RhdGUiLCJjYiIsIm9sZFVybE5vSGFzaCIsIm9sZEhhc2giLCJuZXdVcmxOb0hhc2giLCJuZXdIYXNoIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsVG8iLCJyYXdIYXNoIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiaWRFbCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJuYW1lRWwiLCJnZXRFbGVtZW50c0J5TmFtZSIsInByZWZldGNoIiwib3JpZ2luYWxQYXRobmFtZSIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwiY29tcG9uZW50UmVzdWx0IiwibG9hZFBhZ2UiLCJmbiIsIl9nZXRGbGlnaHREYXRhIiwiY3R4IiwiQXBwVHJlZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});